{
	"fori": {
		"scope": "cpp",
		"prefix": "fori",
		"body": [
			"for(int ${1:i} = 0; ${1:i} < ${2:n}; ++${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"forr": {
		"scope": "cpp",
		"prefix": "forr",
		"body": [
			"for(int ${1:i} = ${2:n} - 1; ${1:i} >= 0; --${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"fori1": {
		"scope": "cpp",
		"prefix": "fori1",
		"body": [
			"for(int ${1:i} = 1; ${1:i} <= ${2:n}; ++${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"forr1": {
		"scope": "cpp",
		"prefix": "forr1",
		"body": [
			"for(int ${1:i} = ${2:n}; ${1:i} >= 1; --${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"2-SAT": {
		"scope": "cpp",
		"prefix": "ps2sat",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/2sat.h",
			"struct TwoSat",
			"{",
			"    int N;",
			"    vector<vector<int>> gr;",
			"    vector<int> values; // 0 = false, 1 = true",
			"",
			"    TwoSat(int n = 0) : N(n), gr(2 * n) {}",
			"",
			"    int addVar()",
			"    {",
			"        // (optional)",
			"        gr.emplace_back();",
			"        gr.emplace_back();",
			"        return N++;",
			"    }",
			"",
			"    void either(int f, int j)",
			"    {",
			"        f = max(2 * f, -1 - 2 * f);",
			"        j = max(2 * j, -1 - 2 * j);",
			"        gr[f].push_back(j ^ 1);",
			"        gr[j].push_back(f ^ 1);",
			"    }",
			"",
			"    void setValue(int x) { either(x, x); }",
			"",
			"    void atMostOne(const vector<int>& li)",
			"    {",
			"        // (optional)",
			"        if(li.size() <= 1) return;",
			"        int cur = ~li[0];",
			"        for(int i = 0; i < li.size(); ++i) {",
			"            int next = addVar();",
			"            either(cur, ~li[i]);",
			"            either(cur, next);",
			"            either(~li[i], next);",
			"            cur = ~next;",
			"        }",
			"        either(cur, ~li[1]);",
			"    }",
			"",
			"    vector<int> val, comp, z;",
			"    int time = 0;",
			"",
			"    int dfs(int i)",
			"    {",
			"        int low = val[i] = ++time, x;",
			"        z.push_back(i);",
			"        for(int e : gr[i])",
			"            if(!comp[e]) low = min(low, val[e] ? val[e] : dfs(e));",
			"        if(low == val[i])",
			"            do {",
			"                x = z.back();",
			"                z.pop_back();",
			"                comp[x] = low;",
			"                if(values[x >> 1] == -1) values[x >> 1] = x & 1;",
			"            } while(x != i);",
			"        return val[i] = low;",
			"    }",
			"",
			"    bool solve()",
			"    {",
			"        values.assign(N, -1);",
			"        val.assign(2 * N, 0);",
			"        comp = val;",
			"        for(int i = 0; i < N * 2; ++i) {",
			"            if(!comp[i]) dfs(i);",
			"        }",
			"        for(int i = 0; i < N; ++i) {",
			"            if(comp[2 * i] == comp[2 * i + 1]) return false;",
			"        }",
			"        return true;",
			"    }",
			"};",
			"// a^b == (~a||~b) & (a||b)",
			"// a eq b == (~a||b) & (a||~b)",
			"// a -> b == (~a||b)",
			"// (a+b+c<=1) == (~a||~b) & (~a||~c) & (~b||~c)",
			""
		]
	},
	"AhoCorasick": {
		"scope": "cpp",
		"prefix": "psahocorasick",
		"body": [
			"struct AhoCorasick",
			"{",
			"    enum { BASE = 'a', NUM = 'z' - 'a' + 1 };",
			"    struct Node",
			"    {",
			"        int nxt[NUM], fail = 0;",
			"        int num = 0;",
			"        Node()",
			"        {",
			"            fill(nxt, nxt + NUM, -1);",
			"        }",
			"    };",
			"    vector<Node> t;",
			"",
			"    AhoCorasick(vector<string>& pat) : t(1)",
			"    {",
			"        for(auto& str : pat) insert(str);",
			"",
			"        queue<int> q; q.push(0);",
			"        while(!q.empty()) {",
			"            int cur = q.front(); q.pop();",
			"            for(int i = 0; i < NUM; ++i) {",
			"                int nx = t[cur].nxt[i];",
			"                if(nx == -1) continue;",
			"",
			"                if(cur == 0) t[nx].fail = 0;",
			"                else {",
			"                    int pre = t[cur].fail;",
			"                    while(pre != 0 && t[pre].nxt[i] == -1) pre = t[pre].fail;",
			"                    if(t[pre].nxt[i] != -1) pre = t[pre].nxt[i];",
			"",
			"                    t[nx].fail = pre;",
			"                    t[nx].num += t[pre].num;",
			"                }",
			"                q.push(nx);",
			"            }",
			"        }",
			"    }",
			"",
			"    void insert(string& str)",
			"    {",
			"        int cur = 0;",
			"        for(int i = 0; i < str.size(); ++i) {",
			"            int ch = str[i] - BASE;",
			"            if(t[cur].nxt[ch] == -1) {",
			"                t[cur].nxt[ch] = t.size();",
			"                t.emplace_back();",
			"            }",
			"            cur = t[cur].nxt[ch];",
			"        }",
			"        t[cur].num++;",
			"    }",
			"",
			"    int search(string& str)",
			"    {",
			"        int cur = 0, res = 0;",
			"        for(int i = 0; i < str.size(); ++i) {",
			"            int ch = str[i] - BASE;",
			"            while(cur != 0 && t[cur].nxt[ch] == -1) cur = t[cur].fail;",
			"            if(t[cur].nxt[ch] != -1) cur = t[cur].nxt[ch];",
			"",
			"            if(cur != 0) res += t[cur].num;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"BCC": {
		"scope": "cpp",
		"prefix": "psbcc",
		"body": [
			"vector<vector<pair<int, int>>> bccs;",
			"vector<int> dep(n, -1); int dNum;",
			"vector<char> isCut(n, false);",
			"vector<pair<int, int>> st;",
			"auto bcc_dfs = [&](auto&& self, int cur, int pre) -> int {",
			"    dep[cur] = dNum++;",
			"    int ret = dep[cur];",
			"    int cNum = 0;",
			"",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre) continue;",
			"",
			"        if(dep[nxt] == -1 || dep[nxt] < dep[cur]) st.push_back({ cur, nxt });",
			"        if(dep[nxt] == -1) {",
			"            cNum++;",
			"            int t = self(self, nxt, cur);",
			"            if(t >= dep[cur]) {",
			"                if(dep[cur] > 0) isCut[cur] = true;",
			"",
			"                bccs.push_back({});",
			"                auto& bcc = bccs.back();",
			"                while(1) {",
			"                    auto eg = st.back(); st.pop_back();",
			"                    bcc.push_back(eg);",
			"",
			"                    if(eg.first == cur) break;",
			"                }",
			"            }",
			"            ret = min(ret, t);",
			"        } else ret = min(ret, dep[nxt]);",
			"    }",
			"",
			"    if(dep[cur] == 0 && cNum > 1) isCut[cur] = true;",
			"    return ret;",
			"};",
			"",
			"for(int i = 0; i < n; ++i) {",
			"    if(dep[i] == -1) {",
			"        dNum = 0;",
			"        bcc_dfs(bcc_dfs, i, -1);",
			"    }",
			"}",
			"// bridges: bcc[i].size() == 1",
			""
		]
	},
	"BCC - Block Cut Tree": {
		"scope": "cpp",
		"prefix": "psbcc_blockcuttree",
		"body": [
			"vector<vector<int>> g2;",
			"vector<int> idx(n);",
			"for(int i = 0; i < n; ++i) {",
			"    if(isCut[i]) {",
			"        idx[i] = g2.size();",
			"        g2.push_back({});",
			"    }",
			"}",
			"vector<char> use(n, false);",
			"for(auto& bcc : bccs) {",
			"    int cur = g2.size();",
			"    g2.push_back({});",
			"    for(auto [u, v] : bcc) {",
			"        if(!use[u]) {",
			"            if(isCut[u]) {",
			"                g[idx[u]].push_back(cur);",
			"                g[cur].push_back(idx[u]);",
			"            } else idx[u] = cur;",
			"            use[u] = true;",
			"        }",
			"        if(!use[v]) {",
			"            if(isCut[v]) {",
			"                g[idx[v]].push_back(cur);",
			"                g[cur].push_back(idx[v]);",
			"            } else idx[v] = cur;",
			"            use[v] = true;",
			"        }",
			"    }",
			"    for(auto [u, v] : bcc) {",
			"        use[u] = false;",
			"        use[v] = false;",
			"    }",
			"}",
			""
		]
	},
	"BCC - Bridge Tree": {
		"scope": "cpp",
		"prefix": "psbcc_bridgetree",
		"body": [
			"DSU dsu(n);",
			"for(auto& bcc : bccs) {",
			"    if(bcc.size() == 1) continue;",
			"    for(auto [u, v] : bcc) dsu.uni(u, v);",
			"}",
			"vector<vector<int>> g2(n);",
			"for(auto& bcc : bccs) {",
			"    if(bcc.size() != 1) continue;",
			"    auto [u, v] = bcc[0];",
			"    u = dsu.find(u); v = dsu.find(v);",
			"",
			"    g[u].push_back(v);",
			"    g[v].push_back(u);",
			"}",
			""
		]
	},
	"Berlekamp-Massey": {
		"scope": "cpp",
		"prefix": "psberlekampmassey",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/BerlekampMassey.h",
			"// usage: ({0, 1, 1, 3, 5, 11}) // {1, 2}",
			"template <ll mod = 998244353>",
			"struct BerlekampMassey",
			"{",
			"    ll modpow(ll b, ll e)",
			"    {",
			"        ll ans = 1;",
			"        for(; e; b = b * b % mod, e /= 2) if(e & 1) ans = ans * b % mod;",
			"        return ans;",
			"    }",
			"",
			"    vector<ll> get(vector<ll> s)",
			"    {",
			"        int n = s.size(), L = 0, m = 0;",
			"        vector<ll> C(n), B(n), T;",
			"        C[0] = B[0] = 1;",
			"",
			"        ll b = 1;",
			"        for(int i = 0; i < n; ++i) {",
			"            ++m;",
			"            ll d = s[i] % mod;",
			"            for(int j = 1; j < L + 1; ++j) {",
			"                d = (d + C[j] * s[i - j]) % mod;",
			"            }",
			"            if(!d) continue;",
			"            T = C;",
			"            ll coef = d * modpow(b, mod - 2) % mod;",
			"            for(int j = m; j < n; ++j) {",
			"                C[j] = (C[j] - coef * B[j - m]) % mod;",
			"            }",
			"            if(2 * L > i) continue;",
			"            L = i + 1 - L;",
			"            B = T;",
			"            b = d;",
			"            m = 0;",
			"        }",
			"",
			"        C.resize(L + 1);",
			"        C.erase(C.begin());",
			"        for(ll& x : C) x = (mod - x) % mod;",
			"        return C;",
			"    }",
			"};",
			""
		]
	},
	"Binomial Coefficient": {
		"scope": "cpp",
		"prefix": "psbicoeff",
		"body": [
			"template <ll mod>",
			"struct BiCoeff",
			"{",
			"    vector<ll> f, invf;",
			"    BiCoeff(int n) : f(n + 1), invf(n + 1)",
			"    {",
			"        f[0] = 1;",
			"        for(int i = 1; i <= n; ++i) f[i] = f[i - 1] * i % mod;",
			"        auto pw = [](ll a, ll b) {",
			"            ll res = 1;",
			"            for(; b > 0; b >>= 1, a = a * a % mod) if(b & 1) res = res * a % mod;",
			"            return res;",
			"        };",
			"        invf[n] = pw(f[n], mod - 2);",
			"        for(int i = n - 1; i >= 0; --i) invf[i] = invf[i + 1] * (i + 1) % mod;",
			"    }",
			"",
			"    ll get(int n, int r)",
			"    {",
			"        return f[n] * (invf[r] * invf[n - r] % mod) % mod;",
			"    }",
			"",
			"    // use BiCoeff bi(mod - 1);",
			"    ll get_lucas(ll n, ll r)",
			"    {",
			"        ll res = 1;",
			"        for(; n > 0 || r > 0; n /= mod, r /= mod) {",
			"            res = res * get(n % mod, r % mod) % mod;",
			"        }",
			"        return mod;",
			"    }",
			"};",
			""
		]
	},
	"Binomial Coefficient - Prime Power": {
		"scope": "cpp",
		"prefix": "psbicoeff_primepower",
		"body": [
			"// idea: https://rkm0959.tistory.com/182",
			"template <int p, int e>",
			"struct BiCoeff_PrimePower",
			"{",
			"    vector<ll> val;",
			"    ll pe;",
			"",
			"    // O(p^e)",
			"    void init()",
			"    {",
			"        pe = 1;",
			"        for(int i = 0; i < e; i++) pe *= p;",
			"",
			"        val.resize(pe);",
			"        val[0] = 1;",
			"        val[1] = 1;",
			"        for(int i = 2; i < pe; ++i) {",
			"            val[i] = val[i - 1];",
			"            if(i % p == 0) continue;",
			"            val[i] *= i;",
			"            val[i] %= pe;",
			"        }",
			"    }",
			"",
			"    // n! = p^k * r  ->  { k, r (mod p^e)  }",
			"    pair<int, ll> getnfact(ll n)",
			"    {",
			"        if(n < p) {",
			"            return { 0, val[n] };",
			"        }",
			"",
			"        pair<int, ll> res;",
			"",
			"        ll div = n / p;",
			"        res.first = div;",
			"",
			"        auto r = getnfact(div);",
			"",
			"        ll div2 = n / pe;",
			"        ll remain2 = n % pe;",
			"",
			"        res.second = val[remain2];",
			"",
			"        if(div2 % 2 == 1) {",
			"            res.second = (res.second * val[pe - 1]) % pe;",
			"        }",
			"",
			"        res.first += r.first;",
			"        res.second = (res.second * r.second) % pe;",
			"        return res;",
			"    }",
			"",
			"    ll invmod(ll a)",
			"    {",
			"        ENode res = eeuc(a, pe);",
			"        ll r = res.s % pe;",
			"        if(r < 0) r += pe;",
			"        return r;",
			"    }",
			"",
			"    // O(logn)",
			"    ll get(ll n, ll r)",
			"    {",
			"        auto nres = getnfact(n);",
			"        auto rres = getnfact(r);",
			"        auto nrres = getnfact(n - r);",
			"",
			"        int pnum = nres.first - rres.first - nrres.first;",
			"        ll remain = (nres.second * invmod((rres.second * nrres.second) % pe)) % pe;",
			"        if(pnum >= e) {",
			"            return 0;",
			"        }",
			"        for(int i = 0; i < pnum; ++i) {",
			"            remain *= p;",
			"            remain %= pe;",
			"        }",
			"        return remain;",
			"    }",
			"};",
			""
		]
	},
	"Bipartite Matching": {
		"scope": "cpp",
		"prefix": "psbipartite",
		"body": [
			"vector<int> a(n, -1), b(m, -1), level(n);",
			"auto initLevel = [&]() {",
			"    queue<int> q;",
			"    for(int i = 0; i < n; ++i) {",
			"        if(a[i] == -1) {",
			"            q.push(i);",
			"            level[i] = 0;",
			"        } else level[i] = -1;",
			"    }",
			"    while(!q.empty()) {",
			"        int cur = q.front(); q.pop();",
			"        for(int nxt : g[cur]) {",
			"            if(b[nxt] != -1 && level[b[nxt]] == -1) {",
			"                level[b[nxt]] = level[cur] + 1;",
			"                q.push(b[nxt]);",
			"            }",
			"        }",
			"    }",
			"};",
			"auto dfs = [&](auto&& self, int cur) -> bool {",
			"    for(int nxt : g[cur]) {",
			"        if(b[nxt] == -1 || (level[b[nxt]] == level[cur] + 1 && self(self, b[nxt]))) {",
			"            a[cur] = nxt;",
			"            b[nxt] = cur;",
			"            return true;",
			"        }",
			"    }",
			"    return false;",
			"};",
			"int flow = 0;",
			"while(1) {",
			"    initLevel();",
			"    int f = 0;",
			"    for(int i = 0; i < n; ++i) {",
			"        if(a[i] == -1 && dfs(dfs, i)) f++;",
			"    }",
			"    if(f == 0) break;",
			"    flow += f;",
			"}",
			""
		]
	},
	"Centroid Decomposition": {
		"scope": "cpp",
		"prefix": "pscentroid",
		"body": [
			"vector<int> sz(n);",
			"vector<char> visit(n, false);",
			"auto getsz = [&](auto&& self, int cur, int pre) -> int {",
			"    sz[cur] = 1;",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        sz[cur] += self(self, nxt, cur);",
			"    }",
			"    return sz[cur];",
			"};",
			"auto getcen = [&](auto&& self, int cur, int pre, int size) -> int {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        if(sz[nxt] > size / 2) return self(self, nxt, cur, size);",
			"    }",
			"    return cur;",
			"};",
			"",
			"auto search = [&](auto&& self, int cur, int pre) -> void {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        self(self, nxt, cur);",
			"    }",
			"};",
			"",
			"vector<int> cenPar(n);",
			"auto centroid = [&](auto&& self, int cur, int pre) -> void {",
			"    int sz = getsz(getsz, cur, -1);",
			"    int cen = getcen(getcen, cur, -1, sz);",
			"",
			"    visit[cen] = true;",
			"    cenPar[cen] = pre;",
			"    search(search, cen, -1);",
			"",
			"    for(int nxt : g[cen]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        self(self, nxt, cen);",
			"    }",
			"};",
			"centroid(centroid, 0, -1);",
			""
		]
	},
	"Convex Hull Trick": {
		"scope": "cpp",
		"prefix": "pscht",
		"body": [
			"struct CHT",
			"{",
			"    struct Line",
			"    {",
			"        ${1:TYPE} a, b; // y = ax + b",
			"    };",
			"    vector<Line> d;",
			"",
			"    double getx(const Line& a, const Line& b)",
			"    {",
			"        return (double)(a.b - b.b) / (double)(b.a - a.a);",
			"    }",
			"",
			"    void insert(${1:TYPE} a, ${1:TYPE} b)",
			"    {",
			"        Line cur = { a, b };",
			"        while(d.size() > 1) {",
			"            Line& b1 = d[d.size() - 1];",
			"            Line& b2 = d[d.size() - 2];",
			"            if(getx(cur, b1) <= getx(b1, b2)) {",
			"                d.pop_back();",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        d.push_back(cur);",
			"    }",
			"",
			"    ${1:TYPE} get(${1:TYPE} x)",
			"    {",
			"        int l = 0, r = d.size() - 1;",
			"        while(l < r) {",
			"            int m = (l + r) / 2;",
			"            if(getx(d[m], d[m + 1]) <= x) {",
			"                l = m + 1;",
			"            } else {",
			"                r = m;",
			"            }",
			"        }",
			"        return d[l].a * x + d[l].b;",
			"    }",
			"};",
			"",
			"// min value -> a decrease",
			"// max value -> a increase",
			""
		]
	},
	"Convex Hull Trick (Decimal Fraction)": {
		"scope": "cpp",
		"prefix": "pscht2",
		"body": [
			"struct CHT",
			"{",
			"    struct Line",
			"    {",
			"        ll a, b; // y = ax + b",
			"    };",
			"",
			"    struct R",
			"    {",
			"        ll u, d;",
			"",
			"        bool operator<=(const R& rhs) const",
			"        {",
			"            return u * rhs.d <= rhs.u * d;",
			"        }",
			"    };",
			"",
			"    vector<Line> d;",
			"    int pos;",
			"",
			"    void clear()",
			"    {",
			"        d.clear();",
			"        pos = 0;",
			"    }",
			"",
			"    R getx(const Line& a, const Line& b)",
			"    {",
			"        ll u = b.b - a.b;",
			"        ll d = a.a - b.a;",
			"        ll g = gcd(u, d);",
			"        return { u / g, d / g };",
			"    }",
			"",
			"    void insert(ll a, ll b)",
			"    {",
			"        Line cur = { a, b };",
			"        while(d.size() > 1) {",
			"            Line& b1 = d[d.size() - 1];",
			"            Line& b2 = d[d.size() - 2];",
			"            if(getx(cur, b1) <= getx(b1, b2)) {",
			"                d.pop_back();",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        d.push_back(cur);",
			"    }",
			"",
			"    ll get(ll x)",
			"    {",
			"        R rx = { x, 1 };",
			"        int l = 0, r = d.size() - 1;",
			"        while(l < r) {",
			"            int m = (l + r) / 2;",
			"            if(getx(d[m], d[m + 1]) <= rx) {",
			"                l = m + 1;",
			"            } else {",
			"                r = m;",
			"            }",
			"        }",
			"        return d[l].a * x + d[l].b;",
			"    }",
			"",
			"    ll get_mono(ll x)",
			"    {",
			"        while(pos < d.size() - 1 && (d[pos].b - d[pos + 1].b) < x * (d[pos + 1].a - d[pos].a)) pos++;",
			"        return d[pos].a * x + d[pos].b;",
			"    }",
			"};",
			"",
			"// min value -> a decrease",
			"// max value -> a increase",
			""
		]
	},
	"Compare Lambda": {
		"scope": "cpp",
		"prefix": "pscompare",
		"body": [
			"[](const auto& l, const auto& r)",
			"{",
			"    return true;",
			"}"
		]
	},
	"Convex Hull_old": {
		"scope": "cpp",
		"prefix": "psconvexhull",
		"body": [
			"void convexHull(vector<Point>& p, vector<Point>& st, bool erase = false)",
			"{",
			"    if(p.size() <= 2) {",
			"        st.assign(p.begin(), p.end());",
			"        if(erase == true) p.clear();",
			"        return;",
			"    }",
			"",
			"    sort(p.begin(), p.end(), [](const Point& l, const Point& r) {",
			"        if(l.y == r.y) return l.x > r.x;",
			"        return l.y > r.y;",
			"    });",
			"    Point pivot = p.back();",
			"    p.pop_back();",
			"    sort(p.begin(), p.end(), [pivot](const Point& l, const Point& r) {",
			"        Point l1 = l - pivot;",
			"        Point l2 = r - pivot;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw == 0) {",
			"            if(l1.y == l2.y) return l1.x < l2.x;",
			"            return l1.y < l2.y;",
			"        } else if(cw > 0) return true;",
			"        else return false;",
			"    });",
			"    st.push_back(pivot);",
			"    st.push_back(p[0]);",
			"    vector<int> eraseIdx;",
			"    eraseIdx.push_back(0);",
			"    for(int i = 1; i < p.size(); ++i) {",
			"        if(st.size() < 2) {",
			"            st.push_back(p[i]);",
			"            eraseIdx.push_back(i);",
			"            continue;",
			"        }",
			"        Point p2 = p[i];",
			"        Point p1 = st[st.size() - 1];",
			"        Point p0 = st[st.size() - 2];",
			"",
			"        Point l1 = p1 - p0;",
			"        Point l2 = p2 - p0;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw > 0) {",
			"            st.push_back(p[i]);",
			"            eraseIdx.push_back(i);",
			"        } else {",
			"            st.pop_back();",
			"            eraseIdx.pop_back();",
			"            i--;",
			"        }",
			"    }",
			"    if(erase == true) {",
			"        sort(eraseIdx.begin(), eraseIdx.end());",
			"        eraseIdx.push_back(-1);",
			"        int ei = 0;",
			"        vector<Point> newp;",
			"        for(int i = 0; i < p.size(); ++i) {",
			"            if(i == eraseIdx[ei]) {",
			"                ei++;",
			"            } else {",
			"                newp.push_back(p[i]);",
			"            }",
			"        }",
			"        p.clear();",
			"        p.assign(newp.begin(), newp.end());",
			"    } else {",
			"        p.push_back(pivot);",
			"    }",
			"}",
			""
		]
	},
	"Chinese Remainder Theorem": {
		"scope": "cpp",
		"prefix": "pscrt",
		"body": [
			"// x = a (mod m)",
			"struct Con { ll a, m; };",
			"Con crt(Con c1, Con c2)",
			"{",
			"    if(c1.m < c2.m) swap(c1, c2);",
			"    ERes r = eeuc(c1.m, c2.m);",
			"    if((c2.a - c1.a) % r.g) return { -1, -1 };",
			"",
			"    Con res;",
			"    res.m = c1.m * c2.m / r.g;",
			"    res.a = (c2.a - c1.a) % c2.m * r.x % c2.m / r.g * c1.m + c1.a;",
			"    if(res.a < 0) res.a += res.m;",
			"    return res;",
			"}",
			""
		]
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "psdijkstra",
		"body": [
			"auto dijk = [&](int st) {",
			"    vector<ll> dst(n, LNF);",
			"    dst[st] = 0;",
			"    struct PNode",
			"    {",
			"        int cur;",
			"        ll cost;",
			"        bool operator<(const PNode& rhs) const { return cost > rhs.cost; }",
			"    };",
			"    priority_queue<PNode> pq;",
			"    pq.push({ st, 0 });",
			"    while(pq.empty() == false) {",
			"        auto [cur, cost] = pq.top();",
			"        pq.pop();",
			"        if(dst[cur] != cost) continue;",
			"",
			"        for(auto [nxt, cost] : g[cur]) {",
			"            if(dst[nxt] > dst[cur] + cost) {",
			"                dst[nxt] = dst[cur] + cost;",
			"                pq.push({ nxt, dst[nxt] });",
			"            }",
			"        }",
			"    }",
			"",
			"    return dst;",
			"};",
			""
		]
	},
	"Disjoint-Set": {
		"scope": "cpp",
		"prefix": "psdsu",
		"body": [
			"struct DSU",
			"{",
			"    int n;",
			"    vector<int> par, sz;",
			"    DSU(int _n) : n(_n), par(_n)",
			"    {",
			"        iota(par.begin(), par.end(), 0);",
			"    }",
			"",
			"    int find(int x)",
			"    {",
			"        while(x != par[x]) x = par[x] = par[par[x]];",
			"        return x;",
			"    }",
			"",
			"    bool uni(int a, int b)",
			"    {",
			"        a = find(a); b = find(b);",
			"        if(a == b) return false;",
			"        par[b] = a;",
			"        return true;",
			"    }",
			"};",
			""
		]
	},
	"Extended Euclidean Algorithm": {
		"scope": "cpp",
		"prefix": "pseeuc",
		"body": [
			"struct ERes { ll x, y, g; };",
			"ERes eeuc(ll a, ll b)",
			"{",
			"    if(b == 0) return { 1, 0, a };",
			"",
			"    ERes res = eeuc(b, a % b);",
			"    ll x = res.y;",
			"    ll y = res.x - a / b * res.y;",
			"    return { x, y, res.g };",
			"}",
			"// Ax+By=C, D=gcd(A,B)=g",
			"// x0 = x * C/D       y0 = y * C/D",
			"// s = x0 + t*B/D   t = y0 - t*A/D",
			""
		]
	},
	"Fash Hash": {
		"scope": "cpp",
		"prefix": "psfasthash",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"",
			"struct splitmix64_hash",
			"{",
			"    // http://xorshift.di.unimi.it/splitmix64.c",
			"    static uint64_t splitmix64(uint64_t x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    uint64_t operator()(uint64_t x) const",
			"    {",
			"        return splitmix64(x + 0x2425260000242526);",
			"    }",
			"};",
			"",
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/HashMap.h",
			"// For CodeForces, or other places where hacking might be a problem:",
			"/*",
			"const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
			"struct random_hash",
			"{ // To use most bits rather than just the lowest ones:",
			"    const uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number",
			"    ll operator()(ll x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
			"};",
			"*/",
			"",
			"template <typename K, typename V>",
			"using hash_map = __gnu_pbds::gp_hash_table<K, V, splitmix64_hash>;",
			"",
			"template <typename K>",
			"using hash_set = hash_map<K, __gnu_pbds::null_type>;",
			"",
			"// hash_map<int, int> table({}, {}, {}, {}, {1 << 16});",
			""
		]
	},
	"Fenwick Tree": {
		"scope": "cpp",
		"prefix": "psfenwick",
		"body": [
			"struct Fenwick",
			"{",
			"    int n;",
			"    vector<ll> t;",
			"    Fenwick(int _n) : n(_n + 1), t(_n + 1, 0) {}",
			"",
			"    void update(int pos, ll dv)",
			"    {",
			"        for(pos++; pos < n; pos += (pos & -pos)) t[pos] += dv;",
			"    }",
			"",
			"    ll query(int pos)",
			"    {",
			"        ll res = 0;",
			"        for(pos++; pos > 0; pos -= (pos & -pos)) res += t[pos];",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Fenwick Tree - Range Update": {
		"scope": "cpp",
		"prefix": "psfenwickrange",
		"body": [
			"struct FenwickRange",
			"{",
			"    int n;",
			"    vector<ll> tmul, tadd;",
			"    FenwickRange(int _n) : n(_n + 1), tmul(_n + 1, 0), tadd(_n + 1, 0) {}",
			"",
			"    void _udt(int pos, ll mul, ll add)",
			"    {",
			"        for(; pos < n; pos += (pos & -pos)) {",
			"            tmul[pos] += mul;",
			"            tadd[pos] += add;",
			"        }",
			"    }",
			"",
			"    void update(int l, int r, ll v)",
			"    {",
			"        l++; r++;",
			"        _udt(l, v, -v * (l - 1));",
			"        _udt(r, -v, v * r);",
			"    }",
			"",
			"    ll query(int pos)",
			"    {",
			"        pos++;",
			"        ll mul = 0, add = 0;",
			"        int st = pos;",
			"        for(; pos > 0; pos -= (pos & -pos)) {",
			"            mul += tmul[pos];",
			"            add += tadd[pos];",
			"        }",
			"        return mul * st + add;",
			"    }",
			"};",
			""
		]
	},
	"Fast Fourier Transform": {
		"scope": "cpp",
		"prefix": "psfft",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastFourierTransform.h",
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastFourierTransformMod.h",
			"struct FFT",
			"{",
			"    using cpx = complex<double>;",
			"",
			"    void fft(vector<cpx>& a)",
			"    {",
			"        int n = a.size(), L = 0;",
			"        while(n > 1) {",
			"            n >>= 1;",
			"            L++;",
			"        }",
			"        n = a.size();",
			"        static vector<complex<long double>> R(2, 1);",
			"        static vector<cpx> rt(2, 1); // (^ 10% faster if double)",
			"        for(static int k = 2; k < n; k *= 2) {",
			"            R.resize(n);",
			"            rt.resize(n);",
			"            auto x = polar(1.0L, acos(-1.0L) / k);",
			"            for(int i = k; i < 2 * k; ++i) {",
			"                rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];",
			"            }",
			"        }",
			"        vector<int> rev(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"        }",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i < rev[i]) swap(a[i], a[rev[i]]);",
			"        }",
			"        for(int k = 1; k < n; k *= 2)",
			"            for(int i = 0; i < n; i += 2 * k) {",
			"                for(int j = 0; j < k; ++j) {",
			"                    cpx z = rt[j + k] * a[i + j + k];",
			"                    a[i + j + k] = a[i + j] - z;",
			"                    a[i + j] += z;",
			"                }",
			"            }",
			"    }",
			"",
			"    vector<ll> conv(const vector<ll>& a, const vector<ll>& b)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        vector<ll> res(a.size() + b.size() - 1);",
			"        int L = 0, n = 1;",
			"        while(n <= res.size()) {",
			"            n <<= 1;",
			"            L++;",
			"        }",
			"",
			"        vector<cpx> in(n), out(n);",
			"        copy(a.begin(), a.end(), begin(in));",
			"        for(int i = 0; i < b.size(); ++i) {",
			"            in[i].imag(b[i]);",
			"        }",
			"        fft(in);",
			"        for(cpx& x : in) x *= x;",
			"        for(int i = 0; i < n; ++i) {",
			"            out[i] = in[-i & (n - 1)] - conj(in[i]);",
			"        }",
			"        fft(out);",
			"        for(int i = 0; i < res.size(); ++i) {",
			"            res[i] = llround(imag(out[i]) / (4 * n));",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<ll> convmod(const vector<ll>& a, const vector<ll>& b, int mod)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        vector<ll> res(a.size() + b.size() - 1);",
			"        int B = 0, n = 1, cut = (int)sqrt(mod);",
			"        while(n <= res.size()) {",
			"            n <<= 1;",
			"            B++;",
			"        }",
			"        vector<cpx> L(n), R(n), outs(n), outl(n);",
			"        for(int i = 0; i < a.size(); ++i) {",
			"            L[i] = cpx((int)a[i] / cut, (int)a[i] % cut);",
			"        }",
			"        for(int i = 0; i < b.size(); ++i) {",
			"            R[i] = cpx((int)b[i] / cut, (int)b[i] % cut);",
			"        }",
			"        fft(L);",
			"        fft(R);",
			"        for(int i = 0; i < n; ++i) {",
			"            int j = -i & (n - 1);",
			"            outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
			"            outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
			"        }",
			"        fft(outl);",
			"        fft(outs);",
			"        for(int i = 0; i < res.size(); ++i) {",
			"            ll av = ll(real(outl[i]) + .5), cv = ll(imag(outs[i]) + .5);",
			"            ll bv = ll(imag(outl[i]) + .5) + ll(real(outs[i]) + .5);",
			"            res[i] = ((av % mod * cut + bv) % mod * cut + cv) % mod;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Flow": {
		"scope": "cpp",
		"prefix": "psflow",
		"body": [
			"struct Flow",
			"{",
			"    using T = int;",
			"    const T T_INF = INF;",
			"",
			"    struct Nxt",
			"    {",
			"        int nxt, revIdx;",
			"        T c, f;",
			"    };",
			"    vector<vector<Nxt>> g;",
			"    vector<int> level, idx;",
			"    Flow(int n) : g(n), level(n), idx(n) {}",
			"    void addEdge(int u, int v, int c, bool biDir = false)",
			"    {",
			"        Nxt uu = { v, -1, c, 0 };",
			"        Nxt vv = { u, -1, 0, 0 };",
			"        if(biDir) vv.c = c;",
			"        uu.revIdx = g[v].size(); vv.revIdx = g[u].size();",
			"        g[u].push_back(uu); g[v].push_back(vv);",
			"    }",
			"    void addFlow(Nxt& e, T f)",
			"    {",
			"        e.f += f;",
			"        g[e.nxt][e.revIdx].f -= f;",
			"    }",
			"",
			"    bool initLevel(int st, int ed)",
			"    {",
			"        fill(level.begin(), level.end(), -1);",
			"        level[st] = 0;",
			"        queue<int> q;",
			"        q.push(st);",
			"        while(!q.empty()) {",
			"            int cur = q.front(); q.pop();",
			"            for(auto [nxt, _, c, f] : g[cur]) {",
			"                if(level[nxt] == -1 && c > f) {",
			"                    level[nxt] = level[cur] + 1;",
			"                    q.push(nxt);",
			"                }",
			"            }",
			"        }",
			"        return level[ed] != -1;",
			"    }",
			"",
			"    T flow(int cur, int ed, T minFlow)",
			"    {",
			"        if(cur == ed) return minFlow;",
			"        for(int& i = idx[cur]; i < g[cur].size(); ++i) {",
			"            auto [nxt, _, c, f] = g[cur][i];",
			"            if(level[nxt] == level[cur] + 1 && c > f) {",
			"                T res = flow(nxt, ed, min(minFlow, c - f));",
			"                if(res > 0) {",
			"                    addFlow(g[cur][i], res);",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"    T maxFlow(int st, int ed)",
			"    {",
			"        T res = 0;",
			"        while(initLevel(st, ed)) {",
			"            fill(idx.begin(), idx.end(), 0);",
			"            T f = flow(st, ed, T_INF);",
			"            if(f == 0) break;",
			"            res += f;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Fast Subset Transform": {
		"scope": "cpp",
		"prefix": "psfst",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastSubsetTransform.h",
			"void FST(vector<ll>& a, bool inv)",
			"{",
			"    for(int n = a.size(), step = 1; step < n; step *= 2) {",
			"        for(int i = 0; i < n; i += 2 * step) {",
			"            for(int j = i; j < i + step; ++j) {",
			"                ll& u = a[j], & v = a[j + step];",
			"                tie(u, v) =",
			"                    inv ? pair<ll, ll>(v - u, u) : pair<ll, ll>(v, u + v);    // AND",
			"                    // inv ? pair<ll, ll>(v, u - v) : pair<ll, ll>(u + v, u); // OR  /// include-line",
			"                    // pair<ll, ll>(u + v, u - v);                            // XOR /// include-line",
			"            }",
			"        }",
			"    }",
			"    // if (inv) for (ll& x : a) x /= a.size(); // XOR only /// include-line",
			"}",
			"vector<ll> conv(vector<ll> a, vector<ll> b)",
			"{",
			"    FST(a, false); FST(b, false);",
			"    for(int i = 0; i < a.size(); ++i) a[i] *= b[i];",
			"    FST(a, true); return a;",
			"}",
			""
		]
	},
	"Gauss-Jordan Elimination": {
		"scope": "cpp",
		"prefix": "psgauss",
		"body": [
			"constexpr double leps = 1e-9;",
			"void gauss(vector<vector<double>>& mat, vector<vector<double>>& res)",
			"{",
			"    int n = mat.size();",
			"    int m = mat[0].size();",
			"    int rm = res[0].size();",
			"",
			"    vector<int> pivot(n, -1);",
			"    int row = 0;",
			"    for(int col = 0; col < m; ++col) {",
			"        int mxrow = row;",
			"        for(int i = row; i < n; ++i) {",
			"            if(abs(mat[i][col]) > abs(mat[mxrow][col])) mxrow = i;",
			"        }",
			"        if(abs(mat[mxrow][col]) < leps) continue;",
			"",
			"        swap(mat[mxrow], mat[row]);",
			"        swap(res[mxrow], res[row]);",
			"        pivot[col] = row;",
			"",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i == row) continue;",
			"            double c = mat[i][col] / mat[row][col];",
			"            for(int j = 0; j < m; ++j) {",
			"                mat[i][j] -= mat[row][j] * c;",
			"            }",
			"            for(int j = 0; j < rm; ++j) {",
			"                res[i][j] -= res[row][j] * c;",
			"            }",
			"        }",
			"",
			"        row++;",
			"    }",
			"",
			"    for(int i = 0; i < n; ++i) {",
			"        double v = 0;",
			"        for(int j = 0; j < m; ++j) {",
			"            if(abs(mat[i][j]) >= leps) {",
			"                v = mat[i][j];",
			"                mat[i][j] = 1;",
			"                break;",
			"            }",
			"        }",
			"        for(int j = 0; j < rm; ++j) {",
			"            res[i][j] /= v;",
			"        }",
			"    }",
			"}",
			""
		]
	},
	"GCC instructions in MSVC": {
		"scope": "cpp",
		"prefix": "psgccinst",
		"body": [
			"#ifdef _MSC_VER",
			"// GCC instructions in MSVC",
			"#include <intrin.h>",
			"#define __builtin_popcount __popcnt",
			"#endif",
			""
		]
	},
	"Geometry": {
		"scope": "cpp",
		"prefix": "psgeo",
		"body": [
			"namespace geo",
			"{",
			"    template <typename T>",
			"    struct PointBase",
			"    {",
			"        using P = PointBase;",
			"",
			"        T x, y;",
			"        PointBase(T _x = 0, T _y = 0) : x(_x), y(_y) {}",
			"",
			"        P operator+(P p) const { return { x + p.x, y + p.y }; }",
			"        P operator-(P p) const { return { x - p.x, y - p.y }; }",
			"        P operator*(T d) const { return { x * d, y * d }; }",
			"        P operator/(T d) const { return { x / d, y / d }; }",
			"",
			"        bool operator<(const P& rhs) const { return tie(x, y) < tie(rhs.x, rhs.y); }",
			"        bool operator==(const P& rhs) const { return tie(x, y) == tie(rhs.x, rhs.y); }",
			"",
			"        T dis2() const { return x * x + y * y; }",
			"        double dis() const { return sqrt((double)dis2()); }",
			"        T dot(P p) const { return x * p.x + y * p.y; }",
			"        T cross(P p) const { return x * p.y - y * p.x; }",
			"        P perp() const { return { -y, x }; } // +90 deg",
			"    };",
			"    template<typename P>",
			"    auto dot(P a, P b) { return a.x * b.x + a.y + b.y; }",
			"    template<typename P>",
			"    auto cross(P a, P b) { return a.x * b.y - a.y * b.x; }",
			"",
			"    using Point = PointBase<double>;",
			"    constexpr double eps = 1e-10;",
			"}",
			""
		]
	},
	"Geometry_old": {
		"scope": "cpp",
		"prefix": "psgeometry",
		"body": [
			"struct Point",
			"{",
			"    ll x, y;",
			"};",
			"Point operator+(const Point& l, const Point& r)",
			"{",
			"    return { l.x + r.x, l.y + r.y };",
			"}",
			"Point operator-(const Point& l, const Point& r)",
			"{",
			"    return { l.x - r.x, l.y - r.y };",
			"}",
			"ll dot(const Point& l, const Point& r)",
			"{",
			"    return l.x * r.x + l.y * r.y;",
			"}",
			"",
			"ll ccw(Point l1, Point l2)",
			"{",
			"    return l1.x * l2.y - l2.x * l1.y;",
			"}",
			"",
			"ll lensq(const Point& a, const Point& b)",
			"{",
			"    ll dx = abs(a.x - b.x);",
			"    ll dy = abs(a.y - b.y);",
			"    return dx * dx + dy * dy;",
			"}",
			""
		]
	},
	"Circumcircle": {
		"scope": "cpp",
		"prefix": "psgeo_circum",
		"body": [
			"template <typename P>",
			"P getCircumcircle(P a, P b, P c)",
			"{",
			"    P ac = c - a, ab = b - a;",
			"    return a + (ac * ab.dis2() - ab * ac.dis2()).perp() / ac.cross(ab) / 2;",
			"}",
			""
		]
	},
	"Convex Hull": {
		"scope": "cpp",
		"prefix": "psgeo_convexhull",
		"body": [
			"vector<Point> getConvexHull(vector<Point> poly)",
			"{",
			"    // line 위 포함 => while 안 cross 등호 빼고, 일자인 경우 예외처리",
			"    if(poly.size() <= 1) return poly;",
			"    sort(poly.begin(), poly.end());",
			"",
			"    vector<Point> lo;",
			"    for(int i = 0; i < poly.size(); ++i) {",
			"        int sz = lo.size();",
			"        auto p = poly[i];",
			"        while(sz >= 2 && cross(lo[sz - 1] - lo[sz - 2], p - lo[sz - 2]) <= 0) {",
			"            lo.pop_back(); sz--;",
			"        }",
			"        lo.push_back(p);",
			"    }",
			"    vector<Point> hi;",
			"    for(int i = poly.size() - 1; i >= 0; --i) {",
			"        int sz = hi.size();",
			"        auto p = poly[i];",
			"        while(sz >= 2 && cross(hi[sz - 1] - hi[sz - 2], p - hi[sz - 2]) <= 0) {",
			"            hi.pop_back(); sz--;",
			"        }",
			"        hi.push_back(p);",
			"    }",
			"",
			"    lo.insert(lo.end(), hi.begin() + 1, hi.end() - 1);",
			"    return lo;",
			"}",
			""
		]
	},
	"Line Distance": {
		"scope": "cpp",
		"prefix": "psgeo_linedis",
		"body": [
			"double getLineDis(Point l1, Point l2, Point p)",
			"{",
			"    Point l = l2 - l1;",
			"    return (double)l.cross(p - l1) / l.dis();",
			"}",
			""
		]
	},
	"Line Intersection": {
		"scope": "cpp",
		"prefix": "psgeo_lineinter",
		"body": [
			"// 0: no inter / 1: has inter / 2: inf inter",
			"pair<int, Point> getLineInter(Point a1, Point a2, Point b1, Point b2)",
			"{",
			"    Point a = a2 - a1, b = b2 - b1;",
			"    auto d = a.cross(b);",
			"    if(d == 0) {",
			"        return { (a.cross(b1 - a1) == 0 ? 2 : 0), { 0, 0 } };",
			"    }",
			"    auto p = (a2 - b1).cross(b);",
			"    auto q = b.cross(a1 - b1);",
			"    return { 1, (a1 * p + a2 * q) / d };",
			"}",
			""
		]
	},
	"Rotating Calipers": {
		"scope": "cpp",
		"prefix": "psgeo_rotatingcalipers",
		"body": [
			"pair<Point, Point> rotatingCalipers(vector<Point>& cvx)",
			"{",
			"    pair<Point, Point> res = { cvx[0], cvx[0] };",
			"    int n = cvx.size(), a = 0, b = 0;",
			"    for(int i = 0; i < n * 2; ++i) {",
			"        if((res.first - res.second).dis2() < (cvx[a] - cvx[b]).dis2()) {",
			"            res = { cvx[a], cvx[b] };",
			"        }",
			"        Point av = cvx[(a + 1) % n] - cvx[a];",
			"        Point bv = cvx[b] - cvx[(b + 1) % n];",
			"        if(av.cross(bv) > 0) a = (a + 1) % n;",
			"        else b = (b + 1) % n;",
			"    }",
			"    return res;",
			"}",
			""
		]
	},
	"Segment Distance": {
		"scope": "cpp",
		"prefix": "psgeo_segdis",
		"body": [
			"double getSegDis(Point s1, Point s2, Point p)",
			"{",
			"    if(s1 == s2) return (p - s1).dis();",
			"    Point s = s2 - s1;",
			"    Point sp = p - s1;",
			"    auto d = s.dis2();",
			"    auto t = min(d, max(0.0, sp.dot(s)));",
			"    return (sp * d - s * t).dis() / d;",
			"}",
			""
		]
	},
	"Segment Intersection": {
		"scope": "cpp",
		"prefix": "psgeo_seginter",
		"body": [
			"vector<Point> getSegInter(Point a1, Point a2, Point b1, Point b2)",
			"{",
			"    Point a = a2 - a1, b = b2 - b1;",
			"    auto ab1 = a.cross(b1 - a1), ab2 = a.cross(b2 - a1);",
			"    auto ba1 = b.cross(a1 - b1), ba2 = b.cross(a2 - b1);",
			"    auto sgn = [](auto x) { return x > 0 ? 1 : (x < 0 ? -1 : 0); };",
			"    if(sgn(ab1) * sgn(ab2) < 0 && sgn(ba1) * sgn(ba2) < 0) {",
			"        return { (a1 * ba2 - a2 * ba1) / (ba2 - ba1) };",
			"    }",
			"    set<Point> s;",
			"    if(isOnSeg(a1, a2, b1)) s.insert(b1);",
			"    if(isOnSeg(a1, a2, b2)) s.insert(b2);",
			"    if(isOnSeg(b1, b2, a1)) s.insert(a1);",
			"    if(isOnSeg(b1, b2, a2)) s.insert(a2);",
			"    return { s.begin(), s.end() };",
			"}",
			""
		]
	},
	"On Segment": {
		"scope": "cpp",
		"prefix": "psgeo_onseg",
		"body": [
			"bool isOnSeg(Point s1, Point s2, Point p)",
			"{",
			"    return (s2 - s1).cross(p - s1) == 0 && (p - s1).dot(p - s2) <= 0;",
			"    // return getSegDis(s1, s2, p) < eps; // Use if double",
			"}",
			""
		]
	},
	"Hash String": {
		"scope": "cpp",
		"prefix": "pshashstr",
		"body": [
			"template <ll h1 = 3137, ll m1 = 998244353, ll h2 = 53, ll m2 = 1610612741>",
			"struct HashStr",
			"{",
			"    vector<ll> v1, pw1, v2, pw2;",
			"",
			"    HashStr(const string& str)",
			"    {",
			"        int n = str.size();",
			"        v1.resize(n); pw1.resize(n);",
			"        v2.resize(n); pw2.resize(n);",
			"        v1[0] = v2[0] = str[0];",
			"        pw1[0] = pw2[0] = 1;",
			"        for(int i = 1; i < n; ++i) {",
			"            v1[i] = (v1[i - 1] * h1 + str[i]) % m1;",
			"            pw1[i] = pw1[i - 1] * h1 % m1;",
			"            v2[i] = (v2[i - 1] * h2 + str[i]) % m2;",
			"            pw2[i] = pw2[i - 1] * h2 % m2;",
			"        }",
			"    }",
			"",
			"    // [l, r]",
			"    ll substr(int l, int r)",
			"    {",
			"        ll res1 = v1[r], res2 = v2[r];",
			"        if(l > 0) {",
			"            ll t = v1[l - 1] * pw1[r - l + 1] % m1;",
			"            res1 = (res1 - t + m1) % m1;",
			"            t = v2[l - 1] * pw2[r - l + 1] % m2;",
			"            res2 = (res2 - t + m2) % m2;",
			"        }",
			"        return res1 << 32 | res2;",
			"    }",
			"};",
			""
		]
	},
	"Hilbert Curve": {
		"scope": "cpp",
		"prefix": "pshilbertcurve",
		"body": [
			"// https://en.wikipedia.org/wiki/Hilbert_curve",
			"//convert (x,y) to d",
			"ll hilbertCurve(int x, int y, ll n)",
			"{",
			"    ll rx, ry, s = 1, d = 0;",
			"    while(s < n) s *= 2;",
			"    n = s;",
			"    for(s = n / 2; s > 0; s /= 2) {",
			"        rx = (x & s) > 0;",
			"        ry = (y & s) > 0;",
			"        d += s * s * ((3 * rx) ^ ry);",
			"        // rotate",
			"        if(ry == 0) {",
			"            if(rx == 1) {",
			"                x = n - 1 - x;",
			"                y = n - 1 - y;",
			"            }",
			"            swap(x, y);",
			"        }",
			"    }",
			"    return d;",
			"}",
			""
		]
	},
	"Heavy-Light Decomposition": {
		"scope": "cpp",
		"prefix": "pshld",
		"body": [
			"vector<int> dep(n), sz(n), top(n), par(n), idx(n);",
			"vector<vector<int>> g2(n);",
			"int num = 0;",
			"",
			"dep[0] = 0; sz[0] = 0;",
			"auto dfs = [&](auto&& self, int cur, int p) -> void {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == p) continue;",
			"",
			"        dep[nxt] = dep[cur] + 1;",
			"        par[nxt] = cur;",
			"        g2[cur].push_back(nxt);",
			"",
			"        self(self, nxt, cur);",
			"    }",
			"};",
			"dfs(dfs, 0, -1);",
			"auto dfs2 = [&](auto&& self, int cur) -> int {",
			"    sz[cur] = 1;",
			"    for(int& nxt : g2[cur]) {",
			"        sz[cur] += self(self, nxt);",
			"",
			"        if(sz[g2[cur][0]] < sz[nxt]) swap(g2[cur][0], nxt);",
			"    }",
			"    return sz[cur];",
			"};",
			"dfs2(dfs2, 0);",
			"",
			"// sg.init(n);",
			"top[0] = 0;",
			"auto hld = [&](auto&& self, int cur) -> void {",
			"    idx[cur] = num++;",
			"    bool heavy = true;",
			"    for(int nxt : g2[cur]) {",
			"        top[nxt] = heavy ? top[cur] : nxt;",
			"        self(self, nxt);",
			"        heavy = false;",
			"    }",
			"};",
			"hld(hld, 0);",
			"// sg.build();",
			""
		]
	},
	"Interactive Helper": {
		"scope": "cpp",
		"prefix": "psinteractive",
		"body": [
			"int qNum, maxQNum;",
			"vector<int> d;",
			"",
			"void get_data(int n)",
			"{",
			"#ifdef CUBE_PS",
			"    maxQNum = n;",
			"    qNum = 0;",
			"",
			"    // ----- Get data from cin -----",
			"    d.resize(n);",
			"    // -----------------------------",
			"#endif",
			"}",
			"",
			"int query()",
			"{",
			"    stringstream ss;",
			"    // ----- Query -----",
			"    ss << \"? \";",
			"    // -----------------",
			"",
			"    int res;",
			"#ifdef CUBE_PS",
			"    cout << \"query: \" << ss.str() << \"\\n\";",
			"    qNum++;",
			"    if(qNum > maxQNum) {",
			"        cout << \"WA: Too many queries (\" << qNum << \")\\n\";",
			"        exit(1);",
			"    }",
			"",
			"    // ----- Get query result -----",
			"    res = 0;",
			"    // ----------------------------",
			"",
			"",
			"    cout << \"  - result: \" << res << \"\\n\";",
			"#else",
			"    cout << ss.str() << endl;",
			"    cin >> res;",
			"#endif",
			"",
			"    return res;",
			"}",
			"",
			"void answer()",
			"{",
			"    stringstream ss;",
			"    // ----- Answer -----",
			"    ss << \"! \";",
			"    // ------------------",
			"",
			"#ifdef CUBE_PS",
			"    cout << \"answer: \" << ss.str() << \"\\n\";",
			"",
			"    // ----- Check validate -----",
			"    bool res = true;",
			"",
			"    // --------------------------",
			"",
			"    if(res == false) {",
			"        cout << \"WA: the answer is incorrect\\n\";",
			"        exit(1);",
			"    } else {",
			"        cout << \"Correct (\" << qNum << \" queries)\\n\";",
			"    }",
			"#else",
			"    cout << ss.str() << endl;",
			"#endif",
			"}",
			""
		]
	},
	"Is Cross_old": {
		"scope": "cpp",
		"prefix": "psiscross",
		"body": [
			"bool isCross(Point l1p1, Point l1p2, Point l2p1, Point l2p2)",
			"{",
			"    Point line = l1p2 - l1p1;",
			"    Point a = l2p1 - l1p2;",
			"    Point b = l2p2 - l1p2;",
			"    ll cwa = ccw(line, a);",
			"    ll cwb = ccw(line, b);",
			"    if((cwa > 0 && cwb > 0) || (cwa < 0 && cwb < 0)) return false;",
			"    if(cwa == 0 && cwb == 0) {",
			"        if(l1p1.x > l1p2.x) swap(l1p1.x, l1p2.x);",
			"        if(l1p1.y > l1p2.y) swap(l1p1.y, l1p2.y);",
			"        if(l2p1.x > l2p2.x) swap(l2p1.x, l2p2.x);",
			"        if(l2p1.y > l2p2.y) swap(l2p1.y, l2p2.y);",
			"",
			"        if(l1p2.x < l2p1.x) return false;",
			"        if(l2p2.x < l1p1.x) return false;",
			"        if(l1p2.y < l2p1.y) return false;",
			"        if(l2p2.y < l1p1.y) return false;",
			"",
			"        return true;",
			"    }",
			"",
			"    line = l2p2 - l2p1;",
			"    a = l1p1 - l2p2;",
			"    b = l1p2 - l2p2;",
			"    cwa = ccw(line, a);",
			"    cwb = ccw(line, b);",
			"    if((cwa > 0 && cwb > 0) || (cwa < 0 && cwb < 0)) return false;",
			"    return true;",
			"}",
			""
		]
	},
	"Is In Line_old": {
		"scope": "cpp",
		"prefix": "psisinline",
		"body": [
			"bool isInLine(Point lp1, Point lp2, Point p)",
			"{",
			"    Point l1 = lp2 - lp1;",
			"    Point l2 = p - lp1;",
			"    ll cw = ccw(l1, l2);",
			"    if(cw != 0) return false;",
			"    else {",
			"        ll dt, dt2;",
			"        if(lp1.x == lp2.x) {",
			"            dt = abs(lp1.y - lp2.y);",
			"            dt2 = max(abs(p.y - lp1.y), abs(p.y - lp2.y));",
			"        } else {",
			"            dt = abs(lp1.x - lp2.x);",
			"            dt2 = max(abs(p.x - lp1.x), abs(p.x - lp2.x));",
			"        }",
			"        if(dt < dt2) return false;",
			"        else return true;",
			"    }",
			"}",
			""
		]
	},
	"Is In Polygon_old": {
		"scope": "cpp",
		"prefix": "psisinpolygon",
		"body": [
			"bool isInPolygon(vector<Point>& pol, Point p)",
			"{",
			"    if(pol.size() == 1) return false;",
			"    else if(pol.size() == 2) return isInLine(pol[0], pol[1], p);",
			"",
			"    for(int i = 1; i < pol.size(); ++i) {",
			"        Point cur = pol[i - 1];",
			"        Point nxt = pol[i];",
			"        Point l1 = nxt - cur;",
			"        Point l2 = p - cur;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw == 0) {",
			"            if(isInLine(nxt, cur, p) == true) return true;",
			"            else return false;",
			"        } else if(cw < 0) {",
			"            return false;",
			"        }",
			"    }",
			"",
			"    return true;",
			"}",
			""
		]
	},
	"Kitamasa": {
		"scope": "cpp",
		"prefix": "pskitamasa",
		"body": [
			"// https://gist.github.com/koosaga/d4afc4434dbaa348d5bef0d60ac36aa4#file-berlekamp_massey-cpp-L43",
			"template <ll mod = 998244353>",
			"struct Kitamasa",
			"{",
			"    int get_nth(const vector<ll>& rec, const vector<ll>& dp, ll n)",
			"    {",
			"        int m = rec.size();",
			"        vector<ll> s(m), t(m);",
			"        s[0] = 1;",
			"        if(m != 1) t[1] = 1;",
			"        else t[0] = rec[0];",
			"        auto mul = [&rec](const vector<ll>& v, const vector<ll>& w) {",
			"            int m = v.size();",
			"            vector<ll> t(2 * m);",
			"            for(int j = 0; j < m; j++) {",
			"                for(int k = 0; k < m; k++) {",
			"                    t[j + k] += 1ll * v[j] * w[k] % mod;",
			"                    if(t[j + k] >= mod) t[j + k] -= mod;",
			"                }",
			"            }",
			"            for(int j = 2 * m - 1; j >= m; j--) {",
			"                for(int k = 1; k <= m; k++) {",
			"                    t[j - k] += 1ll * t[j] * rec[k - 1] % mod;",
			"                    if(t[j - k] >= mod) t[j - k] -= mod;",
			"                }",
			"            }",
			"            t.resize(m);",
			"            return t;",
			"        };",
			"        while(n) {",
			"            if(n & 1) s = mul(s, t);",
			"            t = mul(t, t);",
			"            n >>= 1;",
			"        }",
			"        ll ret = 0;",
			"        for(int i = 0; i < m; i++) ret += 1ll * s[i] * dp[i] % mod;",
			"        return ret % mod;",
			"    }",
			"};",
			"// ex) a_i = a_{i-1} + 2*a_{i-2} / a_0 = 1, a_1 = 3",
			"//     res = ki.get_nth({ 1, 2 }, { 1, 3 }, n);",
			""
		]
	},
	"KMP": {
		"scope": "cpp",
		"prefix": "pskmp",
		"body": [
			"struct KMP",
			"{",
			"    vector<int> fail;",
			"    string w;",
			"    KMP(string& _w) : w(_w), fail(_w.size(), 0)",
			"    {",
			"        int j = 0;",
			"        for(int i = 1; i < w.size(); ++i) {",
			"            while(j > 0 && w[i] != w[j]) j = fail[j - 1];",
			"            if(w[i] == w[j]) fail[i] = ++j;",
			"        }",
			"    }",
			"",
			"    vector<int> match(string& str)",
			"    {",
			"        vector<int> res;",
			"        int j = 0;",
			"        for(int i = 0; i < str.size(); ++i) {",
			"            while(j > 0 && str[i] != w[j]) j = fail[j - 1];",
			"            if(str[i] == w[j]) j++;",
			"            if(j == w.size()) {",
			"                res.push_back(i - j + 1);",
			"                j = fail[j - 1];",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Large Prime Factorization": {
		"scope": "cpp",
		"prefix": "pslargeprimefac",
		"body": [
			"vector<pair<ll, int>> largePrimeFac(ll v)",
			"{",
			"    vector<pair<ll, int>> res;",
			"    ll sqv = sqrtl(v);",
			"",
			"    for(ll f = 2; f <= sqv && v > 1; ++f) {",
			"        if(v % f != 0) continue;",
			"        res.emplace_back(f, 0);",
			"        while(v % f == 0) {",
			"            res.back().second++;",
			"            v /= f;",
			"        }",
			"    }",
			"    if(v > 1) res.emplace_back(v, 1);",
			"",
			"    return res;",
			"}",
			""
		]
	},
	"Lazy Segment Tree": {
		"scope": "cpp",
		"prefix": "pslazysegtree",
		"body": [
			"struct SegTree",
			"{",
			"    using T = int;",
			"    T merge(T l, T r)",
			"    {",
			"        return l + r;",
			"    }",
			"    const T emptyNode = 0;",
			"",
			"    vector<T> t;",
			"    vector<int> lazy;",
			"    int n;",
			"",
			"    SegTree(int _n)",
			"    {",
			"        n = 1;",
			"        while(n < _n) n <<= 1;",
			"",
			"        t.resize(n << 1, emptyNode);",
			"        lazy.resize(n << 1, 0);",
			"    }",
			"",
			"    void initv(int idx, T v)",
			"    {",
			"        t[n + idx] = v;",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for(int i = n - 1; i > 0; --i) t[i] = merge(t[i << 1], t[i << 1 | 1]);",
			"    }",
			"",
			"    void push(int l, int r, int node)",
			"    {",
			"        if(lazy[node] == 0) return;",
			"",
			"        if(node < n) {",
			"            lazy[node << 1] += lazy[node];",
			"            lazy[node << 1 | 1] += lazy[node];",
			"        }",
			"        t[node] += (r - l + 1) * lazy[node];",
			"        lazy[node] = 0;",
			"    }",
			"",
			"    T _qry(int cl, int cr, int l, int r, int node)",
			"    {",
			"        push(cl, cr, node);",
			"        if(cr < l || r < cl) return emptyNode;",
			"        if(l <= cl && cr <= r) return t[node];",
			"        int m = (cl + cr) >> 1;",
			"        return merge(_qry(cl, m, l, r, node << 1), _qry(m + 1, cr, l, r, node << 1 | 1));",
			"    }",
			"",
			"    void _udt(int cl, int cr, int l, int r, int node, T v)",
			"    {",
			"        push(cl, cr, node);",
			"        if(cr < l || r < cl) return;",
			"        if(l <= cl && cr <= r) {",
			"            lazy[node] += v;",
			"            push(cl, cr, node);",
			"            return;",
			"        }",
			"        int m = (cl + cr) >> 1;",
			"        _udt(cl, m, l, r, node << 1, v);",
			"        _udt(m + 1, cr, l, r, node << 1 | 1, v);",
			"        t[node] = merge(t[node << 1], t[node << 1 | 1]);",
			"    }",
			"",
			"    T query(int l, int r)",
			"    {",
			"        return _qry(0, n - 1, l, r, 1);",
			"    }",
			"",
			"    void update(int l, int r, T v)",
			"    {",
			"        _udt(0, n - 1, l, r, 1, v);",
			"    }",
			"};",
			""
		]
	},
	"Li-Chao Tree": {
		"scope": "cpp",
		"prefix": "pslichao",
		"body": [
			"template <bool isMax = false>",
			"struct LiChao",
			"{",
			"    struct Line",
			"    {",
			"        ll a, b; // y = ax + b",
			"        ll getvalue(ll x)",
			"        {",
			"            return x * a + b;",
			"        }",
			"    };",
			"    Line empty;",
			"",
			"    struct Node",
			"    {",
			"        int l = -1, r = -1;",
			"        ll xl, xr;",
			"        Line line;",
			"    };",
			"",
			"    vector<Node> d;",
			"",
			"    void init(ll xmin, ll xmax)",
			"    {",
			"        empty.a = 0;",
			"        empty.b = isMax ? -INF : INF;",
			"        d.push_back({ -1, -1, xmin, xmax, empty });",
			"    }",
			"",
			"    void insert(Line line, int node)",
			"    {",
			"        ll xl = d[node].xl;",
			"        ll xr = d[node].xr;",
			"        Line low = d[node].line;",
			"        Line high = line;",
			"        if(low.getvalue(xl) > high.getvalue(xl)) swap(low, high);",
			"",
			"        if(low.getvalue(xr) <= high.getvalue(xr)) {",
			"            d[node].line = isMax ? high : low;",
			"            return;",
			"        }",
			"",
			"        ll xm = (xl + xr) / 2;",
			"        if(low.getvalue(xm) > high.getvalue(xm)) {",
			"            // 왼쪽에 교점",
			"            d[node].line = isMax ? low : high;",
			"            if(d[node].l == -1) {",
			"                d[node].l = d.size();",
			"                d.push_back({ -1, -1, xl, xm, empty });",
			"            }",
			"            insert(low, d[node].l);",
			"        } else {",
			"            // 오른쪽에 교점",
			"            d[node].line = isMax ? high : low;",
			"            if(d[node].r == -1) {",
			"                d[node].r = d.size();",
			"                d.push_back({ -1, -1, xm + 1, xr, empty });",
			"            }",
			"            insert(high, d[node].r);",
			"        }",
			"    }",
			"",
			"    ll get(ll x, int node)",
			"    {",
			"        if(node == -1) return empty.b;",
			"",
			"        ll xl = d[node].xl;",
			"        ll xr = d[node].xr;",
			"        ll xm = (xl + xr) / 2;",
			"        ll res = d[node].line.getvalue(x);",
			"",
			"        ll cv;",
			"        if(x <= xm) cv = get(x, d[node].l);",
			"        else cv = get(x, d[node].r);",
			"",
			"        if(isMax == false) res = min(res, cv);",
			"        else res = max(res, cv);",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Main": {
		"scope": "cpp",
		"prefix": "psmain",
		"body": [
			"#define _CRT_SECURE_NO_WARNINGS 1",
			"#define _CRT_DECLARE_NONSTDC_NAMES 0 // for using y1 as variable name",
			"",
			"#include <iostream>",
			"#include <cstdio>",
			"#include <utility>",
			"#include <algorithm>",
			"#include <numeric>",
			"#include <vector>",
			"using namespace std;",
			"",
			"using ll = long long int;",
			"constexpr int INF = 0x3f3f3f3f;",
			"constexpr ll LNF = 0x3f3f3f3f3f3f3f3f;",
			"constexpr ll MOD = 1'000'000'007;",
			"",
			"void solve()",
			"{",
			"    ${0}",
			"}",
			"",
			"int main()",
			"{",
			"#ifdef CUBE_PS",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"#endif",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"",
			"    int tNum = 1;",
			"    // cin >> tNum;",
			"    for(int tt = 1; tt <= tNum; tt++) {",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"}",
			""
		]
	},
	"Manacher": {
		"scope": "cpp",
		"prefix": "psmanacher",
		"body": [
			"// d1: ab c ba -> 00200",
			"// d2: ab b a -> 0020",
			"pair<vector<int>, vector<int>> manacher(const string& str)",
			"{",
			"    int n = str.size();",
			"    vector<int> d1(n), d2(n);",
			"    int l = 0, r = -1;",
			"    for(int i = 0; i < n; ++i) {",
			"        int k = 1;",
			"        if(i <= r) {",
			"            k = min(d1[l + r - i], r - i);",
			"        }",
			"        while(0 <= i - k && i + k < n && str[i - k] == str[i + k]) k++;",
			"        d1[i] = --k;",
			"        if(i + k > r) {",
			"            r = i + k;",
			"            l = i - k;",
			"        }",
			"    }",
			"",
			"    l = 0;",
			"    r = -1;",
			"    for(int i = 0; i < n; ++i) {",
			"        int k = 0;",
			"        if(i <= r) {",
			"            k = min(d2[l + r - i + 1], r - i);",
			"        }",
			"        while(0 <= i - k - 1 && i + k < n && str[i - k - 1] == str[i + k]) k++;",
			"        d2[i] = k--;",
			"        if(i + k > r) {",
			"            r = i + k - 1;",
			"            l = i - k;",
			"        }",
			"    }",
			"    return { d1, d2 };",
			"}",
			""
		]
	},
	"Matrix": {
		"scope": "cpp",
		"prefix": "psmatrix",
		"body": [
			"struct Matrix",
			"{",
			"    vector<vector<ll>> d;",
			"    int n;",
			"",
			"    Matrix(int _n) : n(_n)",
			"    {",
			"        d.resize(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            d[i].resize(n);",
			"            for(int j = 0; j < n; ++j) {",
			"                if(i == j) d[i][j] = 1;",
			"                else d[i][j] = 0;",
			"            }",
			"        }",
			"    }",
			"    vector<ll>& operator[](int row) { return d[row]; }",
			"",
			"    void mulself()",
			"    {",
			"        Matrix tmp(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            for(int j = 0; j < n; ++j) {",
			"                tmp.d[i][j] = 0;",
			"                for(int k = 0; k < n; ++k) {",
			"                    tmp.d[i][j] += (d[i][k] * d[k][j]) % MOD;",
			"                    tmp.d[i][j] %= MOD;",
			"                }",
			"            }",
			"        }",
			"        d = move(tmp.d);",
			"    }",
			"",
			"    void mul(const Matrix& b)",
			"    {",
			"        Matrix tmp(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            for(int j = 0; j < n; ++j) {",
			"                tmp.d[i][j] = 0;",
			"                for(int k = 0; k < n; ++k) {",
			"                    tmp.d[i][j] += (d[i][k] * b.d[k][j]) % MOD;",
			"                    tmp.d[i][j] %= MOD;",
			"                }",
			"            }",
			"        }",
			"        d = move(tmp.d);",
			"    }",
			"",
			"    void pow(ll p)",
			"    {",
			"        Matrix res(n);",
			"        while(p > 0) {",
			"            if(p & 1) res.mul(*this);",
			"            mulself();",
			"            p >>= 1;",
			"        }",
			"        d = move(res.d);",
			"    }",
			"};",
			""
		]
	},
	"Min-Cost Max-Flow": {
		"scope": "cpp",
		"prefix": "psmcmf",
		"body": [
			"struct MCMF",
			"{",
			"    using T = ll;",
			"    const T T_INF = LNF;",
			"    struct Nxt",
			"    {",
			"        int nxt, revIdx;",
			"        T c, f, cost;",
			"    };",
			"    vector<vector<Nxt>> g;",
			"    vector<int> pre;",
			"    vector<T> dis;",
			"    vector<Nxt*> eg;",
			"    vector<char> inQ;",
			"    MCMF(int n) : g(n), pre(n), dis(n), eg(n), inQ(n) {}",
			"    void addEdge(int u, int v, T c, T cost)",
			"    {",
			"        Nxt uu = { v, -1, c, 0, cost };",
			"        Nxt vv = { u, -1, 0, 0, -cost };",
			"        uu.revIdx = g[v].size(); vv.revIdx = g[u].size();",
			"        g[u].push_back(uu); g[v].push_back(vv);",
			"    }",
			"    void addFlow(Nxt& e, T f)",
			"    {",
			"        e.f += f;",
			"        g[e.nxt][e.revIdx].f -= f;",
			"    }",
			"",
			"    pair<T, T> flow(int st, int ed)",
			"    {",
			"        fill(pre.begin(), pre.end(), -1);",
			"        fill(dis.begin(), dis.end(), T_INF);",
			"        fill(inQ.begin(), inQ.end(), true);",
			"        queue<int> q;",
			"        q.push(st); inQ[st] = true;",
			"        dis[st] = 0;",
			"        while(!q.empty()) {",
			"            int cur = q.front(); q.pop(); inQ[cur] = false;",
			"            for(auto& nx : g[cur]) {",
			"                auto [nxt, _, c, f, cost] = nx;",
			"                if(c > f && dis[nxt] > dis[cur] + cost) {",
			"                    dis[nxt] = dis[cur] + cost;",
			"                    pre[nxt] = cur;",
			"                    eg[nxt] = &nx;",
			"                    if(!inQ[nxt]) {",
			"                        q.push(nxt); inQ[nxt] = true;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        if(pre[ed] == -1) return { 0, 0 };",
			"        T minF = T_INF;",
			"        for(int i = ed; i != st; i = pre[i]) minF = min(minF, eg[i]->c - eg[i]->f);",
			"        T cost = 0;",
			"        for(int i = ed; i != st; i = pre[i]) {",
			"            addFlow(*eg[i], minF);",
			"            cost += minF * eg[i]->cost;",
			"        }",
			"        return { minF, cost };",
			"    }",
			"",
			"    pair<T, T> maxFlow(int st, int ed)",
			"    {",
			"        pair<T, T> res = { 0, 0 };",
			"        while(1) {",
			"            auto f = flow(st, ed);",
			"            if(f.first == 0) break;",
			"            res.first += f.first;",
			"            res.second += f.second;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Modular Integer": {
		"scope": "cpp",
		"prefix": "psmodint",
		"body": [
			"template <int mod>",
			"struct ModInt",
			"{",
			"    ll v;",
			"    ModInt(ll _v = 0) : v((_v % mod + mod) % mod) {}",
			"    ModInt& operator+=(const ModInt& rhs) {",
			"        v += rhs.v;",
			"        if(v >= mod) v -= mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator-=(const ModInt& rhs) {",
			"        v -= rhs.v;",
			"        if(v < 0) v += mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator*=(const ModInt& rhs) {",
			"        v *= rhs.v;",
			"        v %= mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator/=(const ModInt& rhs) {",
			"        ll n = mod - 2;",
			"        ModInt rev = 1, b = rhs;",
			"        while(n > 0) {",
			"            if(n & 1) rev *= b;",
			"            b *= b;",
			"            n >>= 1;",
			"        }",
			"        return *this *= rev;",
			"    }",
			"    ModInt operator+(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs += rhs;",
			"    }",
			"    ModInt operator-() const { return ModInt() -= *this; }",
			"    ModInt operator-(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs -= rhs;",
			"    }",
			"    ModInt operator*(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs *= rhs;",
			"    }",
			"    ModInt operator/(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs /= rhs;",
			"    }",
			"    friend std::ostream& operator<<(std::ostream& os, const ModInt& n) { return os << n.v; }",
			"    friend std::istream& operator>>(std::istream& is, ModInt& n) {",
			"        ll x;",
			"        is >> x;",
			"        n = ModInt(x);",
			"        return is;",
			"    }",
			"    bool operator==(const ModInt& rhs) const { return v == rhs.v; }",
			"    bool operator!=(const ModInt& rhs) const { return v != rhs.v; }",
			"    ModInt pow(ll k) const {",
			"        ModInt res = 1, p = v;",
			"        while(k > 0) {",
			"            if(k & 1) res *= p;",
			"            p *= p;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"using mint = ModInt<MOD>;",
			""
		]
	},
	"Number-Theoretic Transform": {
		"scope": "cpp",
		"prefix": "psntt",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/NumberTheoreticTransform.h",
			"template <int MOD, int ROOT>",
			"struct NTT",
			"{",
			"    ll modpow(ll a, ll b)",
			"    {",
			"        ll res = 1;",
			"        ll p = a;",
			"        while(b > 0) {",
			"            if(b & 1) {",
			"                res = (res * p) % MOD;",
			"            }",
			"            p = (p * p) % MOD;",
			"            b >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void ntt(vector<ll>& a)",
			"    {",
			"        int n = a.size(), L = 0;",
			"        while(n > 1) {",
			"            n >>= 1;",
			"            L++;",
			"        }",
			"        n = a.size();",
			"        static vector<ll> rt(2, 1);",
			"        for(static int k = 2, s = 2; k < n; k *= 2, s++) {",
			"            rt.resize(n);",
			"            ll z[] = { 1, modpow(ROOT, MOD >> s) };",
			"            for(int i = k; i < 2 * k; ++i) {",
			"                rt[i] = rt[i / 2] * z[i & 1] % MOD;",
			"            }",
			"        }",
			"        vector<int> rev(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"        }",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i < rev[i]) swap(a[i], a[rev[i]]);",
			"        }",
			"        for(int k = 1; k < n; k *= 2) {",
			"            for(int i = 0; i < n; i += 2 * k) {",
			"                for(int j = 0; j < k; ++j) {",
			"                    ll z = rt[j + k] * a[i + j + k] % MOD, &ai = a[i + j];",
			"                    a[i + j + k] = ai - z + (z > ai ? MOD : 0);",
			"                    ai += (ai + z >= MOD ? z - MOD : z);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<ll> conv(const vector<ll>& a, const vector<ll>& b)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        int s = a.size() + b.size() - 1;",
			"        int B = 0, n = 1;",
			"        while(n <= s) {",
			"            n <<= 1;",
			"            B++;",
			"        }",
			"        ll inv = modpow(n, MOD - 2);",
			"        vector<ll> L(a), R(b), out(n);",
			"        L.resize(n), R.resize(n);",
			"        ntt(L), ntt(R);",
			"        for(int i = 0; i < n; ++i) {",
			"            out[-i & (n - 1)] = (ll)L[i] * R[i] % MOD * inv % MOD;",
			"        }",
			"        ntt(out);",
			"        return { out.begin(), out.begin() + s };",
			"    }",
			"};",
			"",
			"// NTT<998244353, 62> ntt;",
			"// NTT<998244353, 3> ntt;",
			"// NTT<167772161, 3> ntt;",
			"// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
			"// and 483 << 21 (same root). The last two are > 10^9.",
			""
		]
	},
	"Persistence Segment Tree": {
		"scope": "cpp",
		"prefix": "pspst",
		"body": [
			"struct PST",
			"{",
			"    using Type = ll;",
			"",
			"    Type merge(Type l, Type r)",
			"    {",
			"        return l + r;",
			"    }",
			"",
			"    const Type empty = 0;",
			"",
			"    struct Node",
			"    {",
			"        int l = -1, r = -1;",
			"        Type v = empty;",
			"    };",
			"",
			"    vector<Node> t;",
			"    int stLeaf;",
			"    vector<int> root;",
			"",
			"    PST(int n)",
			"    {",
			"        root.push_back(1);",
			"",
			"        stLeaf = 1;",
			"        while(stLeaf < n) stLeaf *= 2;",
			"        t.resize(stLeaf * 2);",
			"    }",
			"",
			"    void initv(int idx, Type v)",
			"    {",
			"        t[stLeaf + idx].v = v;",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for(int i = stLeaf - 1; i > 0; --i) {",
			"            t[i].v = merge(t[i * 2].v, t[i * 2 + 1].v);",
			"            t[i].l = i * 2;",
			"            t[i].r = i * 2 + 1;",
			"        }",
			"    }",
			"",
			"    Type queryImpl(int cl, int cr, int l, int r, int node)",
			"    {",
			"        if(l <= cl && cr <= r) return t[node].v;",
			"        else if(cr < l || r < cl) return empty;",
			"        int m = (cl + cr) / 2;",
			"        return merge(queryImpl(cl, m, l, r, t[node].l), queryImpl(m + 1, cr, l, r, t[node].r));",
			"    }",
			"",
			"    Type query(int l, int r, int version)",
			"    {",
			"        return queryImpl(0, stLeaf - 1, l, r, root[version]);",
			"    }",
			"",
			"    void update(int idx, Type v)",
			"    {",
			"        int cl = 0, cr = stLeaf - 1;",
			"        int node = root.back();",
			"",
			"        int newnode = t.size();",
			"        root.push_back(newnode);",
			"        t.push_back(t[node]);",
			"",
			"        while(cl != cr) {",
			"            int m = (cl + cr) / 2;",
			"            if(idx <= m) {",
			"                cr = m;",
			"                t[newnode].l = newnode + 1;",
			"                newnode++;",
			"",
			"                node = t[node].l;",
			"                t.push_back(t[node]);",
			"            } else {",
			"                cl = m + 1;",
			"                t[newnode].r = newnode + 1;",
			"                newnode++;",
			"",
			"                node = t[node].r;",
			"                t.push_back(t[node]);",
			"            }",
			"        }",
			"        t[newnode].v = v;",
			"        newnode--;",
			"        while(newnode >= root.back()) {",
			"            t[newnode].v = merge(t[t[newnode].l].v, t[t[newnode].r].v);",
			"            newnode--;",
			"        }",
			"    }",
			"",
			"    void remove(int numrt)",
			"    {",
			"        int rmrt = root[root.size() - numrt];",
			"        t.erase(t.begin() + rmrt, t.end());",
			"        root.erase(root.end() - numrt, root.end());",
			"    }",
			"};",
			""
		]
	},
	"Random": {
		"scope": "cpp",
		"prefix": "psrandom",
		"body": [
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"uniform_int_distribution<int> distribution(0, INT_MAX);",
			"int getRandom() { return distribution(rng); }",
			""
		]
	},
	"Rotating Calipers_old": {
		"scope": "cpp",
		"prefix": "psrotatingcalipers",
		"body": [
			"ll rotatingCalipers(vector<Point>& cvh)",
			"{",
			"    ll res = 0;",
			"    int cvhn = cvh.size();",
			"",
			"    int aidx = 0, bidx = 0;",
			"    for(int i = 1; i < cvhn; ++i) {",
			"        ll l = lensq(cvh[0], cvh[i]);",
			"        if(res < l) {",
			"            res = l;",
			"            bidx = i;",
			"        }",
			"    }",
			"    for(int i = 0; i < cvhn; ++i) {",
			"        ll l = lensq(cvh[aidx], cvh[bidx]);",
			"        if(res < l) {",
			"            res = l;",
			"        }",
			"        Point av = cvh[(aidx + 1) % cvhn] - cvh[aidx];",
			"        Point bv = cvh[(bidx + 1) % cvhn] - cvh[bidx];",
			"        bv.x = -bv.x;",
			"        bv.y = -bv.y;",
			"        if(ccw(av, bv) > 0) {",
			"            aidx++;",
			"            aidx %= cvhn;",
			"        } else {",
			"            bidx++;",
			"            bidx %= cvhn;",
			"        }",
			"    }",
			"",
			"    return res;",
			"}"
		]
	},
	"SCC": {
		"scope": "cpp",
		"prefix": "psscc",
		"body": [
			"vector<vector<int>> sccs;",
			"vector<int> dep(n, -1), st, sccIdx(n);",
			"vector<char> finish(n, false);",
			"int dNum = 0;",
			"auto scc_dfs = [&](auto&& self, int cur) -> int {",
			"    dep[cur] = dNum++;",
			"    st.push_back(cur);",
			"",
			"    int ret = dep[cur];",
			"    for(int nxt : g[cur]) {",
			"        if(dep[nxt] == -1) ret = min(ret, self(self, nxt));",
			"        else if(!finish[nxt]) ret = min(ret, dep[nxt]);",
			"    }",
			"    if(ret == dep[cur]) {",
			"        sccs.push_back({});",
			"        auto& scc = sccs.back();",
			"        while(1) {",
			"            int top = st.back(); st.pop_back();",
			"            scc.push_back(top);",
			"            sccIdx[top] = sccs.size() - 1;",
			"            finish[top] = true;",
			"            if(top == cur) break;",
			"        }",
			"    }",
			"    return ret;",
			"};",
			"for(int i = 0; i < n; ++i) if(dep[i] == -1) scc_dfs(scc_dfs, i);",
			""
		]
	},
	"Segment List": {
		"scope": "cpp",
		"prefix": "psseglist",
		"body": [
			"struct SegmentList",
			"{",
			"    struct Segment",
			"    {",
			"        ll l, r, v;",
			"    };",
			"    map<ll, Segment> list;",
			"",
			"    SegmentList(ll mn, ll mx, ll v)",
			"    {",
			"        list.insert({ mn, { mn, mx, v } });",
			"    }",
			"",
			"    void insert(ll l, ll r, ll v)",
			"    {",
			"        auto stIt = prev(list.upper_bound(l));",
			"        if(stIt->second.l < l) {",
			"            Segment st = stIt->second;",
			"            list.erase(stIt);",
			"",
			"            Segment st1 = { st.l, l - 1, st.v };",
			"            Segment st2 = { l, st.r, st.v };",
			"            list.insert({ st1.l, st1 });",
			"            list.insert({ st2.l, st2 });",
			"        }",
			"        auto edIt = prev(list.upper_bound(r));",
			"        if(r < edIt->second.r) {",
			"            Segment ed = edIt->second;",
			"            list.erase(edIt);",
			"",
			"            Segment ed1 = { ed.l, r, ed.v };",
			"            Segment ed2 = { r + 1, ed.r, ed.v };",
			"            list.insert({ ed1.l, ed1 });",
			"            list.insert({ ed2.l, ed2 });",
			"        }",
			"        stIt = list.lower_bound(l);",
			"        edIt = list.upper_bound(r);",
			"",
			"        for(auto it = stIt; it != edIt; it = list.erase(it)) {",
			"            // Do something",
			"        }",
			"        Segment s = { l, r, v };",
			"        list.insert({ s.l, s });",
			"    }",
			"};",
			""
		]
	},
	"Segment Tree": {
		"scope": "cpp",
		"prefix": "pssegtree",
		"body": [
			"struct SegTree",
			"{",
			"    using T = ll;",
			"    T merge(T l, T r)",
			"    {",
			"        return l + r;",
			"    }",
			"    constexpr static T empty = 0;",
			"",
			"    int n;",
			"    vector<T> t;",
			"    SegTree(int _n) : n(_n), t(_n * 2, empty) {}",
			"    void initv(int idx, T v)",
			"    {",
			"        t[n + idx] = v;",
			"    }",
			"    void build()",
			"    {",
			"        for(int i = n - 1; i > 0; --i) t[i] = merge(t[i << 1], t[i << 1 | 1]);",
			"    }",
			"",
			"    void update(int pos, T v)",
			"    {",
			"        pos += n;",
			"        t[pos] = v;",
			"        for(pos >>= 1; pos > 0; pos >>= 1) t[pos] = merge(t[pos << 1], t[pos << 1 | 1]);",
			"    }",
			"",
			"    T query(int l, int r)",
			"    {",
			"        T lres = empty, rres = empty;",
			"        for(l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) lres = merge(lres, t[l++]);",
			"            if(r & 1) rres = merge(t[--r], rres);",
			"        }",
			"        return merge(lres, rres);",
			"    }",
			"};",
			""
		]
	},
	"Sieve(MinFactor,Mobius,Prime,Phi) + Prime Fac": {
		"scope": "cpp",
		"prefix": "pssieve",
		"body": [
			"vector<int> minFactor, mobius, primes, phi;",
			"void initSieve(int n)",
			"{",
			"    minFactor.resize(n + 1, 0);",
			"    // mobius.resize(n + 1, 0);",
			"    // mobius[1] = 1;",
			"    for(int i = 2; i <= n; i++) {",
			"        if(minFactor[i] == 0) {",
			"            minFactor[i] = i;",
			"            primes.push_back(i);",
			"        }",
			"        for(int p : primes) {",
			"            if(i * p > n) break;",
			"            minFactor[i * p] = p;",
			"            // mobius[i * p] = (i % p != 0) * (-mobius[i]);",
			"            if(i % p == 0) break;",
			"        }",
			"    }",
			"",
			"    // euler phi",
			"    /*",
			"    phi.resize(n + 1, 0);",
			"    iota(phi.begin(), phi.end(), 0);",
			"    for(int i = 2; i <= n; ++i) {",
			"        if(minFactor[i] != i) continue;",
			"        for(int j = 1; j * i <= n; ++j) {",
			"            phi[i * j] = (i - 1) * (phi[i * j] / i);",
			"        }",
			"    }",
			"    */",
			"}",
			"// phi[i] = (p^a - p^(a-1))...",
			"",
			"vector<pair<int, int>> primeFac(int v)",
			"{",
			"    vector<pair<int, int>> res;",
			"",
			"    while(v > 1) {",
			"        int f = minFactor[v];",
			"        if(res.size() == 0 || res.back().first != f) res.emplace_back(f, 0);",
			"        res.back().second++;",
			"        v /= f;",
			"    }",
			"",
			"    return res;",
			"}",
			""
		]
	},
	"Suffix Array": {
		"scope": "cpp",
		"prefix": "pssuffixarray",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/strings/SuffixArray.h",
			"struct SuffixArray",
			"{",
			"    vector<int> sa, lcp;",
			"    vector<int> ori, lg2;",
			"    vector<vector<int>> st;",
			"",
			"    SuffixArray(string& s, int lim = 256)",
			"    {",
			"        // or basic_string<int>",
			"        int n = s.size() + 1, k = 0, a, b;",
			"        vector<int> x(s.begin(), s.end()), y(n), ws(max(n, lim)), rank(n);",
			"        x.push_back(0);",
			"        sa = lcp = y, iota(sa.begin(), sa.end(), 0);",
			"        for(int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
			"            p = j, iota(y.begin(), y.end(), n - j);",
			"            for(int i = 0; i < n; ++i) if(sa[i] >= j) y[p++] = sa[i] - j;",
			"            fill(ws.begin(), ws.end(), 0);",
			"            for(int i = 0; i < n; ++i) ws[x[i]]++;",
			"            for(int i = 1; i < lim; ++i) ws[i] += ws[i - 1];",
			"            for(int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
			"            swap(x, y), p = 1, x[sa[0]] = 0;",
			"            for(int i = 1; i < n; ++i) {",
			"                a = sa[i - 1], b = sa[i];",
			"                x[b] = (y[a] == y[b] && a + j < n && b + j < n && y[a + j] == y[b + j]) ? p - 1 : p++;",
			"            }",
			"        }",
			"        for(int i = 1; i < n; ++i) rank[sa[i]] = i;",
			"        for(int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
			"            for(k && k--, j = sa[rank[i] - 1];",
			"                i + k < n - 1 && j + k < n - 1 && s[i + k] == s[j + k]; k++);",
			"",
			"        // lcp RMQ build",
			"        lg2.resize(n + 1);",
			"        lg2[0] = lg2[1] = 0;",
			"        for(int i = 2; i <= n; ++i) {",
			"            lg2[i] = lg2[i / 2] + 1;",
			"        }",
			"",
			"        ori.resize(n);",
			"        int dep = lg2[n];",
			"        st.resize(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            ori[sa[i]] = i;",
			"            st[i].resize(dep + 1);",
			"            st[i][0] = lcp[i];",
			"        }",
			"        for(int j = 1; j <= dep; ++j) {",
			"            for(int i = 0; i + (1 << (j - 1)) < n; ++i) {",
			"                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"            }",
			"        }",
			"    }",
			"",
			"    int get_lcp(int l, int r)",
			"    {",
			"        if(l == r) return sa.size() - l - 1;",
			"        l = ori[l], r = ori[r];",
			"        if(l > r) swap(l, r);",
			"        int j = lg2[r - l];",
			"        return min(st[l + 1][j], st[r - (1 << j) + 1][j]);",
			"    }",
			"};",
			"// sa[0] = str.size(), sa.size() = str.size() + 1",
			"// lcp[i] = lcp(sa[i - 1], sa[i]), lcp[0] = 0",
			""
		]
	},
	"TLE Trick": {
		"scope": "cpp",
		"prefix": "pstle",
		"body": [
			"#ifndef CUBE_PS",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#endif",
			""
		]
	},
	"Treap": {
		"scope": "cpp",
		"prefix": "pstreap",
		"body": [
			"struct Treap",
			"{",
			"    Treap* l, * r;",
			"    int pri, sz;",
			"    ll v;",
			"",
			"    Treap(ll _v) : l(0), r(0), pri(getRandom()), sz(1), v(_v) {}",
			"    ~Treap() { delete l; delete r; }",
			"",
			"    void update()",
			"    {",
			"        sz = 1;",
			"        if(l) sz += l->sz;",
			"        if(r) sz += r->sz;",
			"        push();",
			"    }",
			"",
			"    void push() {}",
			"};",
			"",
			"// sz -> left tree size",
			"pair<Treap*, Treap*> split(Treap* cur, int sz)",
			"{",
			"    if(!cur) return { 0, 0 };",
			"    cur->push();",
			"",
			"    int lsz = cur->l ? cur->l->sz : 0;",
			"    if(lsz + 1 <= sz) {",
			"        auto [l, r] = split(cur->r, sz - lsz - 1);",
			"        cur->r = l; cur->update();",
			"        return { cur, r };",
			"    } else {",
			"        auto [l, r] = split(cur->l, sz);",
			"        cur->l = r; cur->update();",
			"        return { l, cur };",
			"    }",
			"}",
			"",
			"Treap* merge(Treap* l, Treap* r)",
			"{",
			"    if(!l) return r; if(!r) return l;",
			"    l->push(); r->push();",
			"",
			"    if(l->pri > r->pri) {",
			"        l->r = merge(l->r, r);",
			"        l->update();",
			"        return l;",
			"    } else {",
			"        r->l = merge(l, r->l);",
			"        r->update();",
			"        return r;",
			"    }",
			"}",
			""
		]
	},
	"Ternary Search": {
		"scope": "cpp",
		"prefix": "pstsearch",
		"body": [
			"auto tsearch = [](ll minx, ll maxx, const function<ll(ll)>& tfunc) {",
			"    ll l = minx, r = maxx;",
			"    while(l + 2 < r) {",
			"        ll p = (l * 2 + r) / 3;",
			"        ll q = (l + r * 2) / 3;",
			"",
			"        ll pv = tfunc(p);",
			"        ll qv = tfunc(q);",
			"",
			"        // min",
			"        if(pv <= qv) r = q;",
			"        else l = p;",
			"        // max",
			"        if(pv <= qv) l = p;",
			"        else r = q;",
			"    }",
			"",
			"    ll res = tfunc(l);",
			"    for(ll i = l + 1; i <= r; ++i) {",
			"        // min",
			"        res = min(res, tfunc(i));",
			"        // max",
			"        res = max(res, tfunc(i));",
			"    }",
			"    return res;",
			"};",
			""
		]
	},
	"Minimum Vertex Cover": {
		"scope": "cpp",
		"prefix": "psvertexcover",
		"body": [
			"// req: psbipartite",
			"auto cover = [&]() {",
			"    vector<char> visitA(n, false), visitB(m, false);",
			"    queue<int> q;",
			"    for(int i = 0; i < n; ++i) if(a[i] == -1) q.push(i);",
			"    while(!q.empty()) {",
			"        int cur = q.front(); q.pop();",
			"        visitA[cur] = true;",
			"        for(int nxt : g[cur]) {",
			"            if(b[nxt] != -1 && !visitB[nxt]) {",
			"                visitB[nxt] = true;",
			"                q.push(b[nxt]);",
			"            }",
			"        }",
			"    }",
			"    vector<int> res;",
			"    for(int i = 0; i < n; ++i) if(!visitA[i]) res.push_back(i);",
			"    for(int i = 0; i < m; ++i) if(visitB[i]) res.push_back(n + i);",
			"    return res;",
			"};",
			""
		]
	},
	"Z-Function": {
		"scope": "cpp",
		"prefix": "pszfunction",
		"body": [
			"vector<int> zfunc(const string& s)",
			"{",
			"    int n = (int)s.size();",
			"    vector<int> z(n);",
			"    for(int i = 1, l = 0, r = 0; i < n; ++i) {",
			"        if(i <= r) z[i] = min(r - i + 1, z[i - l]);",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
			"        if(i + z[i] - 1 > r) {",
			"            l = i;",
			"            r = i + z[i] - 1;",
			"        }",
			"    }",
			"    return z;",
			"}",
			""
		]
	},
	"Temp": {
		"scope": "cpp",
		"prefix": "pstemp",
		"body": []
	},
}