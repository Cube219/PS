{
	"fori": {
		"scope": "cpp",
		"prefix": "fori",
		"body": [
			"for(int ${1:i} = 0; ${1:i} < ${2:n}; ++${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"forr": {
		"scope": "cpp",
		"prefix": "forr",
		"body": [
			"for(int ${1:i} = ${2:n} - 1; ${1:i} >= 0; --${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"fori1": {
		"scope": "cpp",
		"prefix": "fori1",
		"body": [
			"for(int ${1:i} = 1; ${1:i} <= ${2:n}; ++${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"forr1": {
		"scope": "cpp",
		"prefix": "forr1",
		"body": [
			"for(int ${1:i} = ${2:n}; ${1:i} >= 1; --${1:i}) {",
			"    ${0}",
			"}"
		]
	},
	"2-SAT": {
		"scope": "cpp",
		"prefix": "ps2sat",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/2sat.h",
			"struct TwoSat",
			"{",
			"    int N;",
			"    vector<vector<int>> gr;",
			"    vector<int> values; // 0 = false, 1 = true",
			"",
			"    TwoSat(int n = 0) : N(n), gr(2 * n) {}",
			"",
			"    int addVar()",
			"    {",
			"        // (optional)",
			"        gr.emplace_back();",
			"        gr.emplace_back();",
			"        return N++;",
			"    }",
			"",
			"    void either(int f, int j)",
			"    {",
			"        f = max(2 * f, -1 - 2 * f);",
			"        j = max(2 * j, -1 - 2 * j);",
			"        gr[f].push_back(j ^ 1);",
			"        gr[j].push_back(f ^ 1);",
			"    }",
			"",
			"    void setValue(int x) { either(x, x); }",
			"",
			"    void atMostOne(const vector<int>& li)",
			"    {",
			"        // (optional)",
			"        if(li.size() <= 1) return;",
			"        int cur = ~li[0];",
			"        for(int i = 0; i < li.size(); ++i) {",
			"            int next = addVar();",
			"            either(cur, ~li[i]);",
			"            either(cur, next);",
			"            either(~li[i], next);",
			"            cur = ~next;",
			"        }",
			"        either(cur, ~li[1]);",
			"    }",
			"",
			"    vector<int> val, comp, z;",
			"    int time = 0;",
			"",
			"    int dfs(int i)",
			"    {",
			"        int low = val[i] = ++time, x;",
			"        z.push_back(i);",
			"        for(int e : gr[i])",
			"            if(!comp[e]) low = min(low, val[e] ? val[e] : dfs(e));",
			"        if(low == val[i])",
			"            do {",
			"                x = z.back();",
			"                z.pop_back();",
			"                comp[x] = low;",
			"                if(values[x >> 1] == -1) values[x >> 1] = x & 1;",
			"            } while(x != i);",
			"        return val[i] = low;",
			"    }",
			"",
			"    bool solve()",
			"    {",
			"        values.assign(N, -1);",
			"        val.assign(2 * N, 0);",
			"        comp = val;",
			"        for(int i = 0; i < N * 2; ++i) {",
			"            if(!comp[i]) dfs(i);",
			"        }",
			"        for(int i = 0; i < N; ++i) {",
			"            if(comp[2 * i] == comp[2 * i + 1]) return false;",
			"        }",
			"        return true;",
			"    }",
			"};",
			"// a^b == (~a||~b) & (a||b)",
			"// a eq b == (~a||b) & (a||~b)",
			"// a -> b == (~a||b)",
			"// (a+b+c<=1) == (~a||~b) & (~a||~c) & (~b||~c)",
			""
		]
	},
	"AhoCorasick": {
		"scope": "cpp",
		"prefix": "psahocorasick",
		"body": [
			"struct AhoCorasick",
			"{",
			"    constexpr static char BASE = 'A';",
			"    constexpr static int NUM = 'Z' - 'A' + 1;",
			"",
			"    AhoCorasick* nxt[NUM];",
			"    AhoCorasick* fail;",
			"    bool has;",
			"",
			"    AhoCorasick()",
			"    {",
			"        for(int i = 0; i < NUM; ++i) {",
			"            nxt[i] = nullptr;",
			"        }",
			"        fail = nullptr;",
			"        has = false;",
			"    }",
			"",
			"    ~AhoCorasick()",
			"    {",
			"        for(int i = 0; i < NUM; ++i) {",
			"            if(nxt[i] != nullptr) delete nxt[i];",
			"        }",
			"    }",
			"",
			"    void insert(const string& str, int idx)",
			"    {",
			"        if(str.size() == idx) {",
			"            has = true;",
			"            return;",
			"        }",
			"        int ch = str[idx] - BASE;",
			"        if(nxt[ch] == nullptr) nxt[ch] = new AhoCorasick();",
			"        nxt[ch]->insert(str, idx + 1);",
			"    }",
			"",
			"    void build()",
			"    {",
			"        fail = this;",
			"        queue<AhoCorasick*> q;",
			"        q.push(this);",
			"        while(q.empty() == false) {",
			"            AhoCorasick* cur = q.front();",
			"            q.pop();",
			"            for(int i = 0; i < NUM; ++i) {",
			"                if(cur->nxt[i] == nullptr) continue;",
			"                AhoCorasick* nxt = cur->nxt[i];",
			"                if(cur == this) nxt->fail = this;",
			"                else {",
			"                    AhoCorasick* k = cur->fail;",
			"                    while(k != this && k->nxt[i] == nullptr) k = k->fail;",
			"                    if(k->nxt[i] != nullptr) k = k->nxt[i];",
			"                    nxt->fail = k;",
			"                }",
			"                q.push(nxt);",
			"                if(nxt->fail->has == true) nxt->has = true;",
			"            }",
			"        }",
			"    }",
			"",
			"    bool process(const string& str)",
			"    {",
			"        AhoCorasick* cur = this;",
			"        for(int i = 0; i < str.size(); ++i) {",
			"            int ch = str[i] - BASE;",
			"            while(cur != this && cur->nxt[ch] == nullptr) cur = cur->fail;",
			"            if(cur->nxt[ch] != nullptr) cur = cur->nxt[ch];",
			"",
			"            if(cur->has == true) return true;",
			"        }",
			"        return false;",
			"    }",
			"};",
			""
		]
	},
	"BCC": {
		"scope": "cpp",
		"prefix": "psbcc",
		"body": [
			"vector<vector<pair<int, int>>> bcc;",
			"vector<int> d(n, 0), isCut(n, false);",
			"vector<pair<int, int>> st;",
			"int dNum;",
			"auto dfs = [&](auto&& self, int cur, int pre) -> int {",
			"    d[cur] = ++dNum;",
			"",
			"    int ret = d[cur];",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre) continue;",
			"",
			"        if(d[nxt] == 0 || d[cur] > d[nxt]) {",
			"            st.push_back({ cur, nxt });",
			"        }",
			"",
			"        if(d[nxt] == 0) {",
			"            int t = self(self, nxt, cur);",
			"            if(t >= d[cur]) {",
			"                if(d[cur] != 0 || d[nxt] > 1) isCut[cur] = true;",
			"",
			"                bcc.push_back({});",
			"                vector<pair<int, int>>& cbcc = bcc.back();",
			"                while(1) {",
			"                    auto top = st.back();",
			"                    st.pop_back();",
			"",
			"                    cbcc.push_back(top);",
			"                    if(top.first == cur) break;",
			"                }",
			"            }",
			"            ret = min(ret, t);",
			"        } else ret = min(ret, d[nxt]);",
			"    }",
			"",
			"    return ret;",
			"};",
			"for(int i = 0; i < n; ++i) {",
			"    if(d[i] == 0) {",
			"        dNum = 0;",
			"        dfs(dfs, i, -1);",
			"    }",
			"}",
			"// bridges: bcc[i].size() == 1",
			""
		]
	},
	"BCC - Block Cut Tree": {
		"scope": "cpp",
		"prefix": "psbcc_blockcuttree",
		"body": [
			"vector<int> idx(n);",
			"vector<vector<int>> g2;",
			"for(int i = 0; i < n; ++i) {",
			"    if(isCut[i]) {",
			"        g2.emplace_back();",
			"        idx[i] = g2.size() - 1;",
			"    }",
			"}",
			"unordered_map<ll, int> bridges;",
			"vector<char> isUse(n, 0);",
			"for(auto& b : bcc) {",
			"    g2.emplace_back();",
			"    int cur = g2.size() - 1;",
			"    for(auto& p : b) {",
			"        if(!isUse[p.first]) {",
			"            if(isCut[p.first]) {",
			"                g2[cur].emplace_back(idx[p.first]);",
			"                g2[idx[p.first]].emplace_back(cur);",
			"            } else idx[p.first] = cur;",
			"            isUse[p.first] = true;",
			"        }",
			"        if(!isUse[p.second]) {",
			"            if(isCut[p.second]) {",
			"                g2[cur].emplace_back(idx[p.second]);",
			"                g2[idx[p.second]].emplace_back(cur);",
			"            } else idx[p.second] = cur;",
			"            isUse[p.second] = true;",
			"        }",
			"    }",
			"    if(b.size() == 1) {",
			"        ll u = b[0].first;",
			"        ll v = b[0].second;",
			"        if(u > v) swap(u, v);",
			"        bridges.insert({ u << 32 | v, cur });",
			"    }",
			"    for(auto& p : b) {",
			"        isUse[p.first] = false;",
			"        isUse[p.second] = false;",
			"    }",
			"}",
			""
		]
	},
	"BCC - Bridge Tree": {
		"scope": "cpp",
		"prefix": "psbcc_bridgetree",
		"body": [
			"vector<int> par(n);",
			"iota(par.begin(), par.end(), 0);",
			"auto find = [&](int a) {",
			"    vector<int> st;",
			"    while(par[a] != a) {",
			"        st.push_back(a);",
			"        a = par[a];",
			"    }",
			"    for(int v : st) par[v] = a;",
			"    return a;",
			"};",
			"auto uni = [&](int a, int b) {",
			"    int ar = find(a);",
			"    int br = find(b);",
			"    if(ar == br) return;",
			"    par[br] = ar;",
			"};",
			"for(auto& bc : bcc) {",
			"    if(bc.size() == 1) continue;",
			"    for(auto& p : bc) uni(p.first, p.second);",
			"}",
			"vector<vector<int>> g2(n);",
			"for(auto& bc : bcc) {",
			"    if(bc.size() != 1) continue;",
			"    int a = find(bc[0].first);",
			"    int b = find(bc[0].second);",
			"",
			"    g2[a].push_back(b);",
			"    g2[b].push_back(a);",
			"}",
			""
		]
	},
	"Berlekamp-Massey": {
		"scope": "cpp",
		"prefix": "psberlekampmassey",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/BerlekampMassey.h",
			"// usage: ({0, 1, 1, 3, 5, 11}) // {1, 2}",
			"template <ll mod = 998244353>",
			"struct BerlekampMassey",
			"{",
			"    ll modpow(ll b, ll e)",
			"    {",
			"        ll ans = 1;",
			"        for(; e; b = b * b % mod, e /= 2) if(e & 1) ans = ans * b % mod;",
			"        return ans;",
			"    }",
			"",
			"    vector<ll> get(vector<ll> s)",
			"    {",
			"        int n = s.size(), L = 0, m = 0;",
			"        vector<ll> C(n), B(n), T;",
			"        C[0] = B[0] = 1;",
			"",
			"        ll b = 1;",
			"        for(int i = 0; i < n; ++i) {",
			"            ++m;",
			"            ll d = s[i] % mod;",
			"            for(int j = 1; j < L + 1; ++j) {",
			"                d = (d + C[j] * s[i - j]) % mod;",
			"            }",
			"            if(!d) continue;",
			"            T = C;",
			"            ll coef = d * modpow(b, mod - 2) % mod;",
			"            for(int j = m; j < n; ++j) {",
			"                C[j] = (C[j] - coef * B[j - m]) % mod;",
			"            }",
			"            if(2 * L > i) continue;",
			"            L = i + 1 - L;",
			"            B = T;",
			"            b = d;",
			"            m = 0;",
			"        }",
			"",
			"        C.resize(L + 1);",
			"        C.erase(C.begin());",
			"        for(ll& x : C) x = (mod - x) % mod;",
			"        return C;",
			"    }",
			"};",
			""
		]
	},
	"Binomial Coefficient": {
		"scope": "cpp",
		"prefix": "psbicoeff",
		"body": [
			"template <int mod>",
			"struct BiCoeff",
			"{",
			"    vector<ll> fact, invfact;",
			"",
			"    ll pw(ll a, ll b)",
			"    {",
			"        ll res = 1;",
			"        while(b > 0) {",
			"            if(b & 1) {",
			"                res = res * a % mod;",
			"            }",
			"            a = a * a % mod;",
			"            b >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void init(int n)",
			"    {",
			"        fact.resize(n + 1);",
			"        invfact.resize(n + 1);",
			"",
			"        fact[0] = 1;",
			"        for(int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i % mod;",
			"        invfact[n] = pw(fact[n], mod - 2);",
			"        for(int i = n - 1; i >= 0; --i) invfact[i] = invfact[i + 1] * (i + 1) % mod;",
			"    }",
			"",
			"    ll get(int n, int r)",
			"    {",
			"        return fact[n] * (invfact[r] * invfact[n - r] % mod) % mod;",
			"        // return fact[n] * pw(fact[r] * fact[n - r] % mod, mod - 2) % mod;",
			"    }",
			"};",
			""
		]
	},
	"Binomial Coefficient - Lucas": {
		"scope": "cpp",
		"prefix": "psbicoeff_lucas",
		"body": [
			"template <int mod>",
			"struct BiCoeff_Lucas",
			"{",
			"    vector<ll> fact, invfact;",
			"",
			"    ll pw(ll a, ll b)",
			"    {",
			"        ll res = 1;",
			"        while(b > 0) {",
			"            if(b & 1) {",
			"                res = res * a % mod;",
			"            }",
			"            a = a * a % mod;",
			"            b >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    // O(mod)",
			"    void init()",
			"    {",
			"        int n = mod - 1;",
			"        fact.resize(n);",
			"        invfact.resize(n);",
			"",
			"        fact[0] = 1;",
			"        for(int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i % mod;",
			"        invfact[n] = pw(fact[n], mod - 2);",
			"        for(int i = n - 1; i >= 0; --i) invfact[i] = invfact[i + 1] * (i + 1) % mod;",
			"    }",
			"",
			"    ll ncr(int n, int r)",
			"    {",
			"        if(n < r) return 0;",
			"        ll factn = fact[n];",
			"        ll invrnr = invfact[r] * invfact[n - r] % mod;",
			"        return factn * invrnr % mod;",
			"    }",
			"",
			"    // O(logn + logr), Only use when MOD is prime",
			"    ll get(ll n, ll r)",
			"    {",
			"        ll res = 1;",
			"        while(n > 0 || r > 0) {",
			"            ll a = n % mod;",
			"            ll b = r % mod;",
			"            res *= ncr(a, b);",
			"            res %= mod;",
			"",
			"            n /= mod;",
			"            r /= mod;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Binomial Coefficient - Prime Power": {
		"scope": "cpp",
		"prefix": "psbicoeff_primepower",
		"body": [
			"// idea: https://rkm0959.tistory.com/182",
			"template <int p, int e>",
			"struct BiCoeff_PrimePower",
			"{",
			"    vector<ll> val;",
			"    ll pe;",
			"",
			"    // O(p^e)",
			"    void init()",
			"    {",
			"        pe = 1;",
			"        for(int i = 0; i < e; i++) pe *= p;",
			"",
			"        val.resize(pe);",
			"        val[0] = 1;",
			"        val[1] = 1;",
			"        for(int i = 2; i < pe; ++i) {",
			"            val[i] = val[i - 1];",
			"            if(i % p == 0) continue;",
			"            val[i] *= i;",
			"            val[i] %= pe;",
			"        }",
			"    }",
			"",
			"    // n! = p^k * r  ->  { k, r (mod p^e)  }",
			"    pair<int, ll> getnfact(ll n)",
			"    {",
			"        if(n < p) {",
			"            return { 0, val[n] };",
			"        }",
			"",
			"        pair<int, ll> res;",
			"",
			"        ll div = n / p;",
			"        res.first = div;",
			"",
			"        auto r = getnfact(div);",
			"",
			"        ll div2 = n / pe;",
			"        ll remain2 = n % pe;",
			"",
			"        res.second = val[remain2];",
			"",
			"        if(div2 % 2 == 1) {",
			"            res.second = (res.second * val[pe - 1]) % pe;",
			"        }",
			"",
			"        res.first += r.first;",
			"        res.second = (res.second * r.second) % pe;",
			"        return res;",
			"    }",
			"",
			"    ll invmod(ll a)",
			"    {",
			"        ENode res = eeuc(a, pe);",
			"        ll r = res.s % pe;",
			"        if(r < 0) r += pe;",
			"        return r;",
			"    }",
			"",
			"    // O(logn)",
			"    ll get(ll n, ll r)",
			"    {",
			"        auto nres = getnfact(n);",
			"        auto rres = getnfact(r);",
			"        auto nrres = getnfact(n - r);",
			"",
			"        int pnum = nres.first - rres.first - nrres.first;",
			"        ll remain = (nres.second * invmod((rres.second * nrres.second) % pe)) % pe;",
			"        if(pnum >= e) {",
			"            return 0;",
			"        }",
			"        for(int i = 0; i < pnum; ++i) {",
			"            remain *= p;",
			"            remain %= pe;",
			"        }",
			"        return remain;",
			"    }",
			"};",
			""
		]
	},
	"Bipartite Matching": {
		"scope": "cpp",
		"prefix": "psbipartite",
		"body": [
			"vector<int> a(n, -1), b(m, -1);",
			"for(int i = 0; i < n; ++i) {",
			"    if(a[i] != -1) continue;",
			"    vector<char> isComp(n, false);",
			"",
			"    auto dfs = [&](auto&& self, int cur) -> bool {",
			"        isComp[cur] = true;",
			"        for(int nxt : g[cur]) {",
			"            if(b[nxt] == -1) {",
			"                a[cur] = nxt;",
			"                b[nxt] = cur;",
			"                return true;",
			"            } else if(isComp[b[nxt]] == false) {",
			"                bool f = self(self, b[nxt]);",
			"                if(f == true) {",
			"                    a[cur] = nxt;",
			"                    b[nxt] = cur;",
			"                    return true;",
			"                }",
			"            }",
			"        }",
			"        return false;",
			"    };",
			"    dfs(dfs, i);",
			"}",
			""
		]
	},
	"Centroid Decomposition": {
		"scope": "cpp",
		"prefix": "pscentroid",
		"body": [
			"vector<int> sz(n);",
			"vector<char> visit(n, false);",
			"auto getsz = [&](auto&& self, int cur, int pre) -> int {",
			"    sz[cur] = 1;",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        sz[cur] += self(self, nxt, cur);",
			"    }",
			"    return sz[cur];",
			"};",
			"auto getcen = [&](auto&& self, int cur, int pre, int size) -> int {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        if(sz[nxt] > size / 2) return self(self, nxt, cur, size);",
			"    }",
			"    return cur;",
			"};",
			"",
			"auto search = [&](auto&& self, int cur, int pre) -> void {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        self(self, nxt, cur);",
			"    }",
			"};",
			"",
			"auto centroid = [&](auto&& self, int cur, int pre) -> void {",
			"    int sz = getsz(getsz, cur, -1);",
			"    int cen = getcen(getcen, cur, -1, sz);",
			"",
			"    visit[cen] = true;",
			"    search(search, cen, -1);",
			"",
			"    for(int nxt : g[cen]) {",
			"        if(nxt == pre || visit[nxt]) continue;",
			"        self(self, nxt, cen);",
			"    }",
			"};",
			"centroid(centroid, 0, -1);",
			""
		]
	},
	"Convex Hull Trick": {
		"scope": "cpp",
		"prefix": "pscht",
		"body": [
			"struct CHT",
			"{",
			"    struct Line",
			"    {",
			"        ${1:TYPE} a, b; // y = ax + b",
			"    };",
			"    vector<Line> d;",
			"",
			"    double getx(const Line& a, const Line& b)",
			"    {",
			"        return (double)(a.b - b.b) / (double)(b.a - a.a);",
			"    }",
			"",
			"    void insert(${1:TYPE} a, ${1:TYPE} b)",
			"    {",
			"        Line cur = { a, b };",
			"        while(d.size() > 1) {",
			"            Line& b1 = d[d.size() - 1];",
			"            Line& b2 = d[d.size() - 2];",
			"            if(getx(cur, b1) <= getx(b1, b2)) {",
			"                d.pop_back();",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        d.push_back(cur);",
			"    }",
			"",
			"    ${1:TYPE} get(${1:TYPE} x)",
			"    {",
			"        int l = 0, r = d.size() - 1;",
			"        while(l < r) {",
			"            int m = (l + r) / 2;",
			"            if(getx(d[m], d[m + 1]) <= x) {",
			"                l = m + 1;",
			"            } else {",
			"                r = m;",
			"            }",
			"        }",
			"        return d[l].a * x + d[l].b;",
			"    }",
			"};",
			"",
			"// min value -> a decrease",
			"// max value -> a increase",
			""
		]
	},
	"Convex Hull Trick (Decimal Fraction)": {
		"scope": "cpp",
		"prefix": "pscht2",
		"body": [
			"struct CHT",
			"{",
			"    struct Line",
			"    {",
			"        ll a, b; // y = ax + b",
			"    };",
			"",
			"    struct R",
			"    {",
			"        ll u, d;",
			"",
			"        bool operator<=(const R& rhs) const",
			"        {",
			"            return u * rhs.d <= rhs.u * d;",
			"        }",
			"    };",
			"",
			"    vector<Line> d;",
			"    int pos;",
			"",
			"    void clear()",
			"    {",
			"        d.clear();",
			"        pos = 0;",
			"    }",
			"",
			"    R getx(const Line& a, const Line& b)",
			"    {",
			"        ll u = b.b - a.b;",
			"        ll d = a.a - b.a;",
			"        ll g = gcd(u, d);",
			"        return { u / g, d / g };",
			"    }",
			"",
			"    void insert(ll a, ll b)",
			"    {",
			"        Line cur = { a, b };",
			"        while(d.size() > 1) {",
			"            Line& b1 = d[d.size() - 1];",
			"            Line& b2 = d[d.size() - 2];",
			"            if(getx(cur, b1) <= getx(b1, b2)) {",
			"                d.pop_back();",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        d.push_back(cur);",
			"    }",
			"",
			"    ll get(ll x)",
			"    {",
			"        R rx = { x, 1 };",
			"        int l = 0, r = d.size() - 1;",
			"        while(l < r) {",
			"            int m = (l + r) / 2;",
			"            if(getx(d[m], d[m + 1]) <= rx) {",
			"                l = m + 1;",
			"            } else {",
			"                r = m;",
			"            }",
			"        }",
			"        return d[l].a * x + d[l].b;",
			"    }",
			"",
			"    ll get_mono(ll x)",
			"    {",
			"        while(pos < d.size() - 1 && (d[pos].b - d[pos + 1].b) < x * (d[pos + 1].a - d[pos].a)) pos++;",
			"        return d[pos].a * x + d[pos].b;",
			"    }",
			"};",
			"",
			"// min value -> a decrease",
			"// max value -> a increase",
			""
		]
	},
	"Compare Lambda": {
		"scope": "cpp",
		"prefix": "pscompare",
		"body": [
			"[](const auto& l, const auto& r)",
			"{",
			"    return true;",
			"}"
		]
	},
	"Convex Hull_old": {
		"scope": "cpp",
		"prefix": "psconvexhull",
		"body": [
			"void convexHull(vector<Point>& p, vector<Point>& st, bool erase = false)",
			"{",
			"    if(p.size() <= 2) {",
			"        st.assign(p.begin(), p.end());",
			"        if(erase == true) p.clear();",
			"        return;",
			"    }",
			"",
			"    sort(p.begin(), p.end(), [](const Point& l, const Point& r) {",
			"        if(l.y == r.y) return l.x > r.x;",
			"        return l.y > r.y;",
			"    });",
			"    Point pivot = p.back();",
			"    p.pop_back();",
			"    sort(p.begin(), p.end(), [pivot](const Point& l, const Point& r) {",
			"        Point l1 = l - pivot;",
			"        Point l2 = r - pivot;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw == 0) {",
			"            if(l1.y == l2.y) return l1.x < l2.x;",
			"            return l1.y < l2.y;",
			"        } else if(cw > 0) return true;",
			"        else return false;",
			"    });",
			"    st.push_back(pivot);",
			"    st.push_back(p[0]);",
			"    vector<int> eraseIdx;",
			"    eraseIdx.push_back(0);",
			"    for(int i = 1; i < p.size(); ++i) {",
			"        if(st.size() < 2) {",
			"            st.push_back(p[i]);",
			"            eraseIdx.push_back(i);",
			"            continue;",
			"        }",
			"        Point p2 = p[i];",
			"        Point p1 = st[st.size() - 1];",
			"        Point p0 = st[st.size() - 2];",
			"",
			"        Point l1 = p1 - p0;",
			"        Point l2 = p2 - p0;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw > 0) {",
			"            st.push_back(p[i]);",
			"            eraseIdx.push_back(i);",
			"        } else {",
			"            st.pop_back();",
			"            eraseIdx.pop_back();",
			"            i--;",
			"        }",
			"    }",
			"    if(erase == true) {",
			"        sort(eraseIdx.begin(), eraseIdx.end());",
			"        eraseIdx.push_back(-1);",
			"        int ei = 0;",
			"        vector<Point> newp;",
			"        for(int i = 0; i < p.size(); ++i) {",
			"            if(i == eraseIdx[ei]) {",
			"                ei++;",
			"            } else {",
			"                newp.push_back(p[i]);",
			"            }",
			"        }",
			"        p.clear();",
			"        p.assign(newp.begin(), newp.end());",
			"    } else {",
			"        p.push_back(pivot);",
			"    }",
			"}",
			""
		]
	},
	"Chinese Remainder Theorem": {
		"scope": "cpp",
		"prefix": "pscrt",
		"body": [
			"struct CRT",
			"{",
			"    // x = v (mod m)",
			"    struct Con",
			"    {",
			"        ll v, m;",
			"    };",
			"",
			"    Con get(Con c1, Con c2)",
			"    {",
			"        if(c1.m < c2.m) swap(c1, c2);",
			"        ENode en = eeuc(c1.m, c2.m);",
			"        if((c1.v - c2.v) % en.g != 0) return { -1, -1 };",
			"",
			"        ll c = (c2.v - c1.v) % c2.m;",
			"        if(c < 0) c += c2.m;",
			"",
			"        ll resm = c1.m * c2.m / en.g;",
			"        ll resv = (en.s * c) % c2.m / en.g * c1.m + c1.v;",
			"        resv %= resm;",
			"        if(resv < 0) resv += resm;",
			"        return { resv, resm };",
			"    }",
			"};",
			""
		]
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "psdijkstra",
		"body": [
			"vector<ll> dst;",
			"auto dijk = [&](int n, int st) -> void {",
			"    dst.resize(n, LNF);",
			"    dst[st] = 0;",
			"    struct PNode",
			"    {",
			"        int cur; ll cost;",
			"        bool operator<(const PNode& rhs) const { return cost > rhs.cost; }",
			"    };",
			"    priority_queue<PNode> pq;",
			"    pq.push({ 0, st });",
			"    while(pq.empty() == false) {",
			"        auto [cur, cost] = pq.top();",
			"        pq.pop();",
			"        if(dst[cur] != cost) continue;",
			"",
			"        for(auto [nxt, cost] : g[cur]) {",
			"            if(dst[nxt] > dst[cur] + cost) {",
			"                dst[nxt] = dst[cur] + cost;",
			"                pq.push({ dst[nxt], nxt });",
			"            }",
			"        }",
			"    }",
			"};",
			""
		]
	},
	"Disjoint-Set": {
		"scope": "cpp",
		"prefix": "psdsu",
		"body": [
			"struct DSU",
			"{",
			"    int n;",
			"    vector<int> par, sz;",
			"    DSU(int _n) : n(_n), par(_n)",
			"    {",
			"        iota(par.begin(), par.end(), 0);",
			"    }",
			"",
			"    int find(int x)",
			"    {",
			"        while(x != par[x]) x = par[x] = par[par[x]];",
			"        return x;",
			"    }",
			"",
			"    bool uni(int a, int b)",
			"    {",
			"        a = find(a);",
			"        b = find(b);",
			"        if(a == b) return false;",
			"        par[b] = a;",
			"        return true;",
			"    }",
			"};",
			""
		]
	},
	"Extended Euclidean Algorithm": {
		"scope": "cpp",
		"prefix": "pseeuc",
		"body": [
			"struct ENode",
			"{",
			"    ll s;",
			"    ll t;",
			"    ll g;",
			"};",
			"",
			"ENode eeuc(ll a, ll b)",
			"{",
			"    if(b == 0) return { 1, 0, a };",
			"",
			"    ll r = a % b;",
			"    auto res = eeuc(b, r);",
			"    ll x = res.t;",
			"    ll y = res.s - a / b * res.t;",
			"    return { x, y, res.g };",
			"}",
			"// Ax+By=C, D=gcd(A, B)=g",
			"// x0 = s * C/D       y0 = t * C/D",
			"// s = x0 + k * B/D   t = y0 - k * A/D",
			""
		]
	},
	"Fash Hash": {
		"scope": "cpp",
		"prefix": "psfasthash",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"",
			"struct splitmix64_hash",
			"{",
			"    // http://xorshift.di.unimi.it/splitmix64.c",
			"    static uint64_t splitmix64(uint64_t x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    uint64_t operator()(uint64_t x) const",
			"    {",
			"        return splitmix64(x + 0x2425260000242526);",
			"    }",
			"};",
			"",
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/HashMap.h",
			"// For CodeForces, or other places where hacking might be a problem:",
			"/*",
			"const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
			"struct random_hash",
			"{ // To use most bits rather than just the lowest ones:",
			"    const uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number",
			"    ll operator()(ll x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
			"};",
			"*/",
			"",
			"template <typename K, typename V>",
			"using hash_map = __gnu_pbds::gp_hash_table<K, V, splitmix64_hash>;",
			"",
			"template <typename K>",
			"using hash_set = hash_map<K, __gnu_pbds::null_type>;",
			"",
			"// hash_map<int, int> table({}, {}, {}, {}, {1 << 16});",
			""
		]
	},
	"Fenwick Tree": {
		"scope": "cpp",
		"prefix": "psfenwick",
		"body": [
			"struct Fenwick",
			"{",
			"    int n;",
			"    vector<ll> t;",
			"    Fenwick(int _n) : n(_n + 1), t(_n + 1, 0)",
			"    {}",
			"",
			"    void update(int pos, ll dv)",
			"    {",
			"        pos++;",
			"        for(; pos < n; pos += (pos & -pos)) t[pos] += dv;",
			"    }",
			"",
			"    ll query(int pos)",
			"    {",
			"        pos++;",
			"        ll res = 0;",
			"        for(; pos > 0; pos -= (pos & -pos)) res += t[pos];",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Fenwick Tree - Range Update": {
		"scope": "cpp",
		"prefix": "psfenwickrange",
		"body": [
			"struct FenwickRange",
			"{",
			"    int n;",
			"    vector<ll> tmul, tadd;",
			"    FenwickRange(int _n) : n(_n + 1), tmul(_n + 1, 0), tadd(_n + 1, 0)",
			"    {}",
			"",
			"    void update(int l, int r, ll v)",
			"    {",
			"        l++; r++;",
			"        udtImpl(l, v, -v * (l - 1));",
			"        udtImpl(r, -v, v * r);",
			"    }",
			"",
			"    void udtImpl(int pos, ll mul, ll add)",
			"    {",
			"        for(; pos < n; pos += (pos & -pos)) {",
			"            tmul[pos] += mul;",
			"            tadd[pos] += add;",
			"        }",
			"    }",
			"",
			"    ll query(int pos)",
			"    {",
			"        pos++;",
			"        ll mul = 0, add = 0;",
			"        int st = pos;",
			"        for(; pos > 0; pos -= (pos & -pos)) {",
			"            mul += tmul[pos];",
			"            add += tadd[pos];",
			"        }",
			"        return mul * st + add;",
			"    }",
			"};",
			""
		]
	},
	"Fast Fourier Transform": {
		"scope": "cpp",
		"prefix": "psfft",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastFourierTransform.h",
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastFourierTransformMod.h",
			"struct FFT",
			"{",
			"    using cpx = complex<double>;",
			"",
			"    void fft(vector<cpx>& a)",
			"    {",
			"        int n = a.size(), L = 0;",
			"        while(n > 1) {",
			"            n >>= 1;",
			"            L++;",
			"        }",
			"        n = a.size();",
			"        static vector<complex<long double>> R(2, 1);",
			"        static vector<cpx> rt(2, 1); // (^ 10% faster if double)",
			"        for(static int k = 2; k < n; k *= 2) {",
			"            R.resize(n);",
			"            rt.resize(n);",
			"            auto x = polar(1.0L, acos(-1.0L) / k);",
			"            for(int i = k; i < 2 * k; ++i) {",
			"                rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];",
			"            }",
			"        }",
			"        vector<int> rev(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"        }",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i < rev[i]) swap(a[i], a[rev[i]]);",
			"        }",
			"        for(int k = 1; k < n; k *= 2)",
			"            for(int i = 0; i < n; i += 2 * k) {",
			"                for(int j = 0; j < k; ++j) {",
			"                    cpx z = rt[j + k] * a[i + j + k];",
			"                    a[i + j + k] = a[i + j] - z;",
			"                    a[i + j] += z;",
			"                }",
			"            }",
			"    }",
			"",
			"    vector<ll> conv(const vector<ll>& a, const vector<ll>& b)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        vector<ll> res(a.size() + b.size() - 1);",
			"        int L = 0, n = 1;",
			"        while(n <= res.size()) {",
			"            n <<= 1;",
			"            L++;",
			"        }",
			"",
			"        vector<cpx> in(n), out(n);",
			"        copy(a.begin(), a.end(), begin(in));",
			"        for(int i = 0; i < b.size(); ++i) {",
			"            in[i].imag(b[i]);",
			"        }",
			"        fft(in);",
			"        for(cpx& x : in) x *= x;",
			"        for(int i = 0; i < n; ++i) {",
			"            out[i] = in[-i & (n - 1)] - conj(in[i]);",
			"        }",
			"        fft(out);",
			"        for(int i = 0; i < res.size(); ++i) {",
			"            res[i] = llround(imag(out[i]) / (4 * n));",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<ll> convmod(const vector<ll>& a, const vector<ll>& b, int mod)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        vector<ll> res(a.size() + b.size() - 1);",
			"        int B = 0, n = 1, cut = (int)sqrt(mod);",
			"        while(n <= res.size()) {",
			"            n <<= 1;",
			"            B++;",
			"        }",
			"        vector<cpx> L(n), R(n), outs(n), outl(n);",
			"        for(int i = 0; i < a.size(); ++i) {",
			"            L[i] = cpx((int)a[i] / cut, (int)a[i] % cut);",
			"        }",
			"        for(int i = 0; i < b.size(); ++i) {",
			"            R[i] = cpx((int)b[i] / cut, (int)b[i] % cut);",
			"        }",
			"        fft(L);",
			"        fft(R);",
			"        for(int i = 0; i < n; ++i) {",
			"            int j = -i & (n - 1);",
			"            outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
			"            outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
			"        }",
			"        fft(outl);",
			"        fft(outs);",
			"        for(int i = 0; i < res.size(); ++i) {",
			"            ll av = ll(real(outl[i]) + .5), cv = ll(imag(outs[i]) + .5);",
			"            ll bv = ll(imag(outl[i]) + .5) + ll(real(outs[i]) + .5);",
			"            res[i] = ((av % mod * cut + bv) % mod * cut + cv) % mod;",
			"        }",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Flow": {
		"scope": "cpp",
		"prefix": "psflow",
		"body": [
			"struct Flow",
			"{",
			"    using Type = ll;",
			"",
			"    struct Edge",
			"    {",
			"        int dst;",
			"        Type c;",
			"        Type f;",
			"        int revIdx;",
			"    };",
			"",
			"    vector<vector<Edge>> g;",
			"    int n;",
			"    vector<int> level, work;",
			"",
			"    Flow(int _n)",
			"    {",
			"        n = _n;",
			"        g.resize(n);",
			"        level.resize(n);",
			"        work.resize(n);",
			"    }",
			"",
			"    void addEdge(int s, int e, Type c, bool biDir = false)",
			"    {",
			"        Edge e1 = { e, c, 0, -1 };",
			"        Edge e2 = { s, 0, 0, -1 };",
			"        if(biDir == true) e2.c = c;",
			"        e1.revIdx = g[e].size();",
			"        e2.revIdx = g[s].size();",
			"        g[s].push_back(e1);",
			"        g[e].push_back(e2);",
			"    }",
			"",
			"    void addFlow(Edge& e, Type f)",
			"    {",
			"        e.f += f;",
			"        g[e.dst][e.revIdx].f -= f;",
			"    }",
			"",
			"    bool initLevel(int st, int ed)",
			"    {",
			"        for(int i = 0; i < n; ++i) {",
			"            level[i] = -1;",
			"        }",
			"        level[st] = 0;",
			"        queue<int> q;",
			"        q.push(st);",
			"        while(q.empty() == false) {",
			"            int cur = q.front();",
			"            q.pop();",
			"            for(auto& nx : g[cur]) {",
			"                int nxt = nx.dst;",
			"                Type c = nx.c;",
			"                Type f = nx.f;",
			"                if(level[nxt] == -1 && c > f) {",
			"                    level[nxt] = level[cur] + 1;",
			"                    q.push(nxt);",
			"                }",
			"            }",
			"        }",
			"        if(level[ed] == -1) return false;",
			"        return true;",
			"    }",
			"",
			"    Type flow(int cur, int ed, Type minFlow)",
			"    {",
			"        if(cur == ed) return minFlow;",
			"",
			"        for(int i = work[cur]; i < g[cur].size(); ++i) {",
			"            auto& nx = g[cur][i];",
			"            int nxt = nx.dst;",
			"            Type c = nx.c;",
			"            Type f = nx.f;",
			"            if(level[nxt] == level[cur] + 1 && c > f) {",
			"                Type res = flow(nxt, ed, min(minFlow, c - f));",
			"                if(res > 0) {",
			"                    addFlow(nx, res);",
			"                    return res;",
			"                }",
			"            }",
			"            work[cur]++;",
			"        }",
			"        return 0;",
			"    }",
			"",
			"    Type maxFlow(int st, int ed)",
			"    {",
			"        Type res = 0;",
			"        while(1) {",
			"            if(initLevel(st, ed) == false) break;",
			"            for(int i = 0; i < n; ++i) {",
			"                work[i] = 0;",
			"            }",
			"            while(1) {",
			"                Type f = flow(st, ed, INF);",
			"                if(f == 0) break;",
			"                res += f;",
			"            }",
			"        }",
			"",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Flow_old": {
		"scope": "cpp",
		"prefix": "psflow_old",
		"body": [
			"template <int N>",
			"class Flow",
			"{",
			"public:",
			"    using TYPE = ll;",
			"",
			"    struct Edge",
			"    {",
			"        int dst;",
			"        TYPE c;",
			"        TYPE f;",
			"        int revIdx;",
			"    };",
			"",
			"    vector<Edge> g[N + 1];",
			"    int pre[N + 1];",
			"    Edge* path[N + 1];",
			"    int n;",
			"",
			"    void init(int _n)",
			"    {",
			"        n = _n;",
			"        for(int i = 0; i < n; ++i) {",
			"            g[i].clear();",
			"        }",
			"    }",
			"",
			"    void addEdge(int s, int e, TYPE c, bool biDir = false)",
			"    {",
			"        Edge e1 = { e, c, 0, -1 };",
			"        Edge e2 = { s, 0, 0, -1 };",
			"        if(biDir == true) e2.c = c;",
			"        e1.revIdx = g[e].size();",
			"        e2.revIdx = g[s].size();",
			"        g[s].push_back(e1);",
			"        g[e].push_back(e2);",
			"    }",
			"",
			"    void addFlow(Edge& e, TYPE f)",
			"    {",
			"        e.f += f;",
			"        g[e.dst][e.revIdx].f -= f;",
			"    }",
			"",
			"    TYPE flow(int st, int ed)",
			"    {",
			"        for(int i = 0; i <= n; ++i) {",
			"            pre[i] = -1;",
			"        }",
			"        queue<int> q;",
			"        q.push(st);",
			"        while(q.empty() == false && pre[ed] == -1) {",
			"            int cur = q.front();",
			"            q.pop();",
			"            for(auto& nx : g[cur]) {",
			"                int nxt = nx.dst;",
			"                TYPE c = nx.c;",
			"                TYPE f = nx.f;",
			"                if(c > f && pre[nxt] == -1) {",
			"                    pre[nxt] = cur;",
			"                    path[nxt] = &nx;",
			"                    q.push(nxt);",
			"                    if(nxt == ed) break;",
			"                }",
			"            }",
			"        }",
			"        if(pre[ed] == -1) return 0;",
			"        TYPE flow = INF;",
			"        int idx = ed;",
			"        while(idx != st) {",
			"            flow = min(flow, path[idx]->c - path[idx]->f);",
			"            idx = pre[idx];",
			"        }",
			"        idx = ed;",
			"        while(idx != st) {",
			"            addFlow(*path[idx], flow);",
			"            idx = pre[idx];",
			"        }",
			"        return flow;",
			"    }",
			"",
			"    TYPE maxFlow(int st, int ed)",
			"    {",
			"        TYPE res = 0;",
			"        while(1) {",
			"            TYPE f = flow(st, ed);",
			"            if(f == 0) break;",
			"            res += f;",
			"        }",
			"",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Fast Subset Transform": {
		"scope": "cpp",
		"prefix": "psfst",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastSubsetTransform.h",
			"void FST(vector<ll>& a, bool inv)",
			"{",
			"    for(int n = a.size(), step = 1; step < n; step *= 2) {",
			"        for(int i = 0; i < n; i += 2 * step) {",
			"            for(int j = i; j < i + step; ++j) {",
			"                ll& u = a[j], & v = a[j + step];",
			"                tie(u, v) =",
			"                    inv ? pair<ll, ll>(v - u, u) : pair<ll, ll>(v, u + v);    // AND",
			"                    // inv ? pair<ll, ll>(v, u - v) : pair<ll, ll>(u + v, u); // OR  /// include-line",
			"                    // pair<ll, ll>(u + v, u - v);                            // XOR /// include-line",
			"            }",
			"        }",
			"    }",
			"    // if (inv) for (ll& x : a) x /= a.size(); // XOR only /// include-line",
			"}",
			"vector<ll> conv(vector<ll> a, vector<ll> b)",
			"{",
			"    FST(a, false); FST(b, false);",
			"    for(int i = 0; i < a.size(); ++i) a[i] *= b[i];",
			"    FST(a, true); return a;",
			"}",
			""
		]
	},
	"Gauss-Jordan Elimination": {
		"scope": "cpp",
		"prefix": "psgauss",
		"body": [
			"constexpr double leps = 1e-9;",
			"void gauss(vector<vector<double>>& mat, vector<vector<double>>& res)",
			"{",
			"    int n = mat.size();",
			"    int m = mat[0].size();",
			"    int rm = res[0].size();",
			"",
			"    vector<int> pivot(n, -1);",
			"    int row = 0;",
			"    for(int col = 0; col < m; ++col) {",
			"        int mxrow = row;",
			"        for(int i = row; i < n; ++i) {",
			"            if(abs(mat[i][col]) > abs(mat[mxrow][col])) mxrow = i;",
			"        }",
			"        if(abs(mat[mxrow][col]) < leps) continue;",
			"",
			"        swap(mat[mxrow], mat[row]);",
			"        swap(res[mxrow], res[row]);",
			"        pivot[col] = row;",
			"",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i == row) continue;",
			"            double c = mat[i][col] / mat[row][col];",
			"            for(int j = 0; j < m; ++j) {",
			"                mat[i][j] -= mat[row][j] * c;",
			"            }",
			"            for(int j = 0; j < rm; ++j) {",
			"                res[i][j] -= res[row][j] * c;",
			"            }",
			"        }",
			"",
			"        row++;",
			"    }",
			"",
			"    for(int i = 0; i < n; ++i) {",
			"        double v = 0;",
			"        for(int j = 0; j < m; ++j) {",
			"            if(abs(mat[i][j]) >= leps) {",
			"                v = mat[i][j];",
			"                mat[i][j] = 1;",
			"                break;",
			"            }",
			"        }",
			"        for(int j = 0; j < rm; ++j) {",
			"            res[i][j] /= v;",
			"        }",
			"    }",
			"}",
			""
		]
	},
	"GCC instructions in MSVC": {
		"scope": "cpp",
		"prefix": "psgccinst",
		"body": [
			"#ifdef _MSC_VER",
			"// GCC instructions in MSVC",
			"#include <intrin.h>",
			"#define __builtin_popcount __popcnt",
			"#endif",
			""
		]
	},
	"Geometry": {
		"scope": "cpp",
		"prefix": "psgeo",
		"body": [
			"namespace geo",
			"{",
			"    template <typename T>",
			"    struct PointBase",
			"    {",
			"        using P = PointBase;",
			"",
			"        T x, y;",
			"        PointBase(T _x = 0, T _y = 0) : x(_x), y(_y) {}",
			"",
			"        P operator+(P p) const { return { x + p.x, y + p.y }; }",
			"        P operator-(P p) const { return { x - p.x, y - p.y }; }",
			"        P operator*(T d) const { return { x * d, y * d }; }",
			"        P operator/(T d) const { return { x / d, y / d }; }",
			"",
			"        bool operator<(const P& rhs) const { return tie(x, y) < tie(rhs.x, rhs.y); }",
			"        bool operator==(const P& rhs) const { return tie(x, y) == tie(rhs.x, rhs.y); }",
			"",
			"        T dis2() const { return x * x + y * y; }",
			"        double dis() const { return sqrt((double)dis2()); }",
			"        T dot(P p) const { return x * p.x + y * p.y; }",
			"        T cross(P p) const { return x * p.y - y * p.x; }",
			"        P perp() const { return { -y, x }; } // +90 deg",
			"    };",
			"    template<typename P>",
			"    auto dot(P a, P b) { return a.x * b.x + a.y + b.y; }",
			"    template<typename P>",
			"    auto cross(P a, P b) { return a.x * b.y - a.y * b.x; }",
			"",
			"    using Point = PointBase<double>;",
			"}",
			""
		]
	},
	"Geometry_old": {
		"scope": "cpp",
		"prefix": "psgeometry",
		"body": [
			"struct Point",
			"{",
			"    ll x, y;",
			"};",
			"Point operator+(const Point& l, const Point& r)",
			"{",
			"    return { l.x + r.x, l.y + r.y };",
			"}",
			"Point operator-(const Point& l, const Point& r)",
			"{",
			"    return { l.x - r.x, l.y - r.y };",
			"}",
			"ll dot(const Point& l, const Point& r)",
			"{",
			"    return l.x * r.x + l.y * r.y;",
			"}",
			"",
			"ll ccw(Point l1, Point l2)",
			"{",
			"    return l1.x * l2.y - l2.x * l1.y;",
			"}",
			"",
			"ll lensq(const Point& a, const Point& b)",
			"{",
			"    ll dx = abs(a.x - b.x);",
			"    ll dy = abs(a.y - b.y);",
			"    return dx * dx + dy * dy;",
			"}",
			""
		]
	},
	"Circumcircle": {
		"scope": "cpp",
		"prefix": "psgeo_circum",
		"body": [
			"template <typename P>",
			"P getCircumcircle(P a, P b, P c)",
			"{",
			"    P ac = c - a, ab = b - a;",
			"    return a + (ac * ab.dis2() - ab * ac.dis2()).perp() / ac.cross(ab) / 2;",
			"}",
			""
		]
	},
	"Convex Hull": {
		"scope": "cpp",
		"prefix": "psgeo_convexhull",
		"body": [
			"template <typename P>",
			"vector<P> convexHull(vector<P>& poly, bool erase = false)",
			"{",
			"    // line 위 포함 => while 안 cross 등호 빼고, 일자인 경우 예외처리",
			"    if(poly.size() <= 1) {",
			"        auto newPoly = poly;",
			"        if(erase) poly.clear();",
			"        return newPoly;",
			"    }",
			"",
			"    vector<int> eraseIdx;",
			"",
			"    sort(poly.begin(), poly.end());",
			"    vector<P> up;",
			"    for(int i = 0; i < poly.size(); ++i) {",
			"        int sz = up.size();",
			"        auto& p = poly[i];",
			"        while(sz >= 2 && cross(up[sz - 1] - up[sz - 2], p - up[sz - 2]) <= 0) {",
			"            up.pop_back();",
			"            eraseIdx.pop_back();",
			"            sz--;",
			"        }",
			"        up.push_back(p);",
			"        eraseIdx.push_back(i);",
			"    }",
			"",
			"    vector<P> lo;",
			"    for(int i = poly.size() - 1; i >= 0; --i) {",
			"        int sz = lo.size();",
			"        auto& p = poly[i];",
			"        while(sz >= 2 && cross(lo[sz - 1] - lo[sz - 2], p - lo[sz - 2]) <= 0) {",
			"            lo.pop_back();",
			"            eraseIdx.pop_back();",
			"            sz--;",
			"        }",
			"        lo.push_back(p);",
			"        eraseIdx.push_back(i);",
			"    }",
			"",
			"    if(erase) {",
			"        sort(eraseIdx.begin(), eraseIdx.end());",
			"        eraseIdx.push_back(poly.size());",
			"        vector<P> newPoly;",
			"        int ei = 0;",
			"        for(int i = 0; i < poly.size(); ++i) {",
			"            while(eraseIdx[ei] < i) ei++;",
			"            if(eraseIdx[ei] == i) ei++;",
			"            else newPoly.push_back(poly[i]);",
			"        }",
			"",
			"        poly = newPoly;",
			"    }",
			"",
			"    up.insert(up.end(), lo.begin() + 1, lo.end() - 1);",
			"    return up;",
			"}",
			""
		]
	},
	"Line Distance": {
		"scope": "cpp",
		"prefix": "psgeo_linedis",
		"body": [
			"template <typename P>",
			"double getLineDis(P a1, P a2, P p)",
			"{",
			"    Point a = a2 - a1;",
			"    return a.cross(p - a1) / a.dis();",
			"}",
			""
		]
	},
	"Line Interaction": {
		"scope": "cpp",
		"prefix": "psgeo_lineinter",
		"body": [
			"// num=0: no inter / num=1: has inter / num=2: inf inter",
			"template <typename P>",
			"P getLineInter(P a1, P a2, P b1, P b2, int& num)",
			"{",
			"    P a = a2 - a1, b = b2 - b1;",
			"    auto d = a.cross(b);",
			"    if(d == 0) {",
			"        if(a.cross(b1 - a1) == 0) num = 2;",
			"        else num = 0;",
			"        return { 0, 0 };",
			"    }",
			"    auto p = (a2 - b1).cross(b);",
			"    auto q = b.cross(a1 - b1);",
			"    num = 1;",
			"    return (a1 * p + a2 * q) / d;",
			"}",
			""
		]
	},
	"Hash String": {
		"scope": "cpp",
		"prefix": "pshashstr",
		"body": [
			"template <ll h1 = 3137, ll m1 = 998244353, ll h2 = 53, ll m2 = 1610612741>",
			"struct HashStr",
			"{",
			"    vector<ll> hv, hpow;",
			"    vector<ll> hv2, hpow2;",
			"",
			"    HashStr(const string& str)",
			"    {",
			"        int n = str.size();",
			"        hv.resize(n);",
			"        hpow.resize(n);",
			"",
			"        hv[0] = str[0];",
			"        hpow[0] = 1;",
			"        for(int i = 1; i < n; ++i) {",
			"            hv[i] = (hv[i - 1] * h1 + str[i]) % m1;",
			"            hpow[i] = (hpow[i - 1] * h1) % m1;",
			"        }",
			"",
			"        hv2.resize(n);",
			"        hpow2.resize(n);",
			"",
			"        hv2[0] = str[0];",
			"        hpow2[0] = 1;",
			"        for(int i = 1; i < n; ++i) {",
			"            hv2[i] = (hv2[i - 1] * h2 + str[i]) % m2;",
			"            hpow2[i] = (hpow2[i - 1] * h2) % m2;",
			"        }",
			"    }",
			"",
			"    // [l, r]",
			"    ll substr(int l, int r)",
			"    {",
			"        ll res = hv[r];",
			"        if(l > 0) {",
			"            res -= hv[l - 1] * hpow[r - l + 1];",
			"            res = ((res % m1) + m1) % m1;",
			"        }",
			"        ll res2 = hv[r];",
			"        if(l > 0) {",
			"            res2 -= hv2[l - 1] * hpow2[r - l + 1];",
			"            res2 = ((res2 % m2) + m2) % m2;",
			"        }",
			"        return res << 32 | res2;",
			"    }",
			"};",
			""
		]
	},
	"Hilbert Curve": {
		"scope": "cpp",
		"prefix": "pshilbertcurve",
		"body": [
			"// https://en.wikipedia.org/wiki/Hilbert_curve",
			"//convert (x,y) to d",
			"int hilbertCurve(int x, int y, int n = (1 << 21))",
			"{",
			"    n = (1 << (n - 1));",
			"    int rx, ry, s, d = 0;",
			"    for(s = n / 2; s > 0; s /= 2) {",
			"        rx = (x & s) > 0;",
			"        ry = (y & s) > 0;",
			"        d += s * s * ((3 * rx) ^ ry);",
			"",
			"        // rotate",
			"        if(ry == 0) {",
			"            if(rx == 1) {",
			"                x = n - 1 - x;",
			"                y = n - 1 - y;",
			"            }",
			"",
			"            swap(x, y);",
			"        }",
			"    }",
			"    return d;",
			"}",
			""
		]
	},
	"Heavy-Light Decomposition": {
		"scope": "cpp",
		"prefix": "pshld",
		"body": [
			"vector<int> dep(n), sz(n), top(n), par(n), idx(n);",
			"vector<vector<int>> g2(n);",
			"int num = 0;",
			"",
			"dep[0] = 0; sz[0] = 0;",
			"auto dfs = [&](auto&& self, int cur, int p) -> void {",
			"    for(int nxt : g[cur]) {",
			"        if(nxt == p) continue;",
			"",
			"        dep[nxt] = dep[cur] + 1;",
			"        par[nxt] = cur;",
			"        g2[cur].push_back(nxt);",
			"",
			"        self(self, nxt, cur);",
			"    }",
			"};",
			"dfs(dfs, 0, -1);",
			"auto dfs2 = [&](auto&& self, int cur) -> int {",
			"    sz[cur] = 1;",
			"    for(int& nxt : g2[cur]) {",
			"        sz[cur] += self(self, nxt);",
			"",
			"        if(sz[g2[cur][0]] < sz[nxt]) swap(g2[cur][0], nxt);",
			"    }",
			"    return sz[cur];",
			"};",
			"dfs2(dfs2, 0);",
			"",
			"// sg.init(n);",
			"top[0] = 0;",
			"auto hld = [&](auto&& self, int cur) -> void {",
			"    idx[cur] = num++;",
			"    for(int nxt : g2[cur]) {",
			"        if(g2[cur][0] == nxt) top[nxt] = top[cur];",
			"        else top[nxt] = nxt;",
			"        self(self, nxt);",
			"    }",
			"};",
			"hld(hld, 0);",
			"// sg.build();",
			""
		]
	},
	"Interactive Helper": {
		"scope": "cpp",
		"prefix": "psinteractive",
		"body": [
			"int qNum, maxQNum;",
			"vector<int> d;",
			"",
			"void get_data(int n)",
			"{",
			"#ifdef CUBE_PS",
			"    maxQNum = n;",
			"    qNum = 0;",
			"",
			"    // ----- Get data from cin -----",
			"    d.resize(n);",
			"    // -----------------------------",
			"#endif",
			"}",
			"",
			"int query()",
			"{",
			"    stringstream ss;",
			"    // ----- Query -----",
			"    ss << \"? \";",
			"    // -----------------",
			"",
			"    int res;",
			"#ifdef CUBE_PS",
			"    cout << \"query: \" << ss.str() << \"\\n\";",
			"    qNum++;",
			"    if(qNum > maxQNum) {",
			"        cout << \"WA: Too many queries (\" << qNum << \")\\n\";",
			"        exit(1);",
			"    }",
			"",
			"    // ----- Get query result -----",
			"    res = 0;",
			"    // ----------------------------",
			"",
			"",
			"    cout << \"  - result: \" << res << \"\\n\";",
			"#else",
			"    cout << ss.str() << endl;",
			"    cin >> res;",
			"#endif",
			"",
			"    return res;",
			"}",
			"",
			"void answer()",
			"{",
			"    stringstream ss;",
			"    // ----- Answer -----",
			"    ss << \"! \";",
			"    // ------------------",
			"",
			"#ifdef CUBE_PS",
			"    cout << \"answer: \" << ss.str() << \"\\n\";",
			"",
			"    // ----- Check validate -----",
			"    bool res = true;",
			"",
			"    // --------------------------",
			"",
			"    if(res == false) {",
			"        cout << \"WA: the answer is incorrect\\n\";",
			"        exit(1);",
			"    } else {",
			"        cout << \"Correct (\" << qNum << \" queries)\\n\";",
			"    }",
			"#else",
			"    cout << ss.str() << endl;",
			"#endif",
			"}",
			""
		]
	},
	"Is Cross_old": {
		"scope": "cpp",
		"prefix": "psiscross",
		"body": [
			"bool isCross(Point l1p1, Point l1p2, Point l2p1, Point l2p2)",
			"{",
			"    Point line = l1p2 - l1p1;",
			"    Point a = l2p1 - l1p2;",
			"    Point b = l2p2 - l1p2;",
			"    ll cwa = ccw(line, a);",
			"    ll cwb = ccw(line, b);",
			"    if((cwa > 0 && cwb > 0) || (cwa < 0 && cwb < 0)) return false;",
			"    if(cwa == 0 && cwb == 0) {",
			"        if(l1p1.x > l1p2.x) swap(l1p1.x, l1p2.x);",
			"        if(l1p1.y > l1p2.y) swap(l1p1.y, l1p2.y);",
			"        if(l2p1.x > l2p2.x) swap(l2p1.x, l2p2.x);",
			"        if(l2p1.y > l2p2.y) swap(l2p1.y, l2p2.y);",
			"",
			"        if(l1p2.x < l2p1.x) return false;",
			"        if(l2p2.x < l1p1.x) return false;",
			"        if(l1p2.y < l2p1.y) return false;",
			"        if(l2p2.y < l1p1.y) return false;",
			"",
			"        return true;",
			"    }",
			"",
			"    line = l2p2 - l2p1;",
			"    a = l1p1 - l2p2;",
			"    b = l1p2 - l2p2;",
			"    cwa = ccw(line, a);",
			"    cwb = ccw(line, b);",
			"    if((cwa > 0 && cwb > 0) || (cwa < 0 && cwb < 0)) return false;",
			"    return true;",
			"}",
			""
		]
	},
	"Is In Line_old": {
		"scope": "cpp",
		"prefix": "psisinline",
		"body": [
			"bool isInLine(Point lp1, Point lp2, Point p)",
			"{",
			"    Point l1 = lp2 - lp1;",
			"    Point l2 = p - lp1;",
			"    ll cw = ccw(l1, l2);",
			"    if(cw != 0) return false;",
			"    else {",
			"        ll dt, dt2;",
			"        if(lp1.x == lp2.x) {",
			"            dt = abs(lp1.y - lp2.y);",
			"            dt2 = max(abs(p.y - lp1.y), abs(p.y - lp2.y));",
			"        } else {",
			"            dt = abs(lp1.x - lp2.x);",
			"            dt2 = max(abs(p.x - lp1.x), abs(p.x - lp2.x));",
			"        }",
			"        if(dt < dt2) return false;",
			"        else return true;",
			"    }",
			"}",
			""
		]
	},
	"Is In Polygon_old": {
		"scope": "cpp",
		"prefix": "psisinpolygon",
		"body": [
			"bool isInPolygon(vector<Point>& pol, Point p)",
			"{",
			"    if(pol.size() == 1) return false;",
			"    else if(pol.size() == 2) return isInLine(pol[0], pol[1], p);",
			"",
			"    for(int i = 1; i < pol.size(); ++i) {",
			"        Point cur = pol[i - 1];",
			"        Point nxt = pol[i];",
			"        Point l1 = nxt - cur;",
			"        Point l2 = p - cur;",
			"        ll cw = ccw(l1, l2);",
			"        if(cw == 0) {",
			"            if(isInLine(nxt, cur, p) == true) return true;",
			"            else return false;",
			"        } else if(cw < 0) {",
			"            return false;",
			"        }",
			"    }",
			"",
			"    return true;",
			"}",
			""
		]
	},
	"Kitamasa": {
		"scope": "cpp",
		"prefix": "pskitamasa",
		"body": [
			"// https://gist.github.com/koosaga/d4afc4434dbaa348d5bef0d60ac36aa4#file-berlekamp_massey-cpp-L43",
			"template <ll mod = 998244353>",
			"struct Kitamasa",
			"{",
			"    int get_nth(const vector<ll>& rec, const vector<ll>& dp, ll n)",
			"    {",
			"        int m = rec.size();",
			"        vector<ll> s(m), t(m);",
			"        s[0] = 1;",
			"        if(m != 1) t[1] = 1;",
			"        else t[0] = rec[0];",
			"        auto mul = [&rec](const vector<ll>& v, const vector<ll>& w) {",
			"            int m = v.size();",
			"            vector<ll> t(2 * m);",
			"            for(int j = 0; j < m; j++) {",
			"                for(int k = 0; k < m; k++) {",
			"                    t[j + k] += 1ll * v[j] * w[k] % mod;",
			"                    if(t[j + k] >= mod) t[j + k] -= mod;",
			"                }",
			"            }",
			"            for(int j = 2 * m - 1; j >= m; j--) {",
			"                for(int k = 1; k <= m; k++) {",
			"                    t[j - k] += 1ll * t[j] * rec[k - 1] % mod;",
			"                    if(t[j - k] >= mod) t[j - k] -= mod;",
			"                }",
			"            }",
			"            t.resize(m);",
			"            return t;",
			"        };",
			"        while(n) {",
			"            if(n & 1) s = mul(s, t);",
			"            t = mul(t, t);",
			"            n >>= 1;",
			"        }",
			"        ll ret = 0;",
			"        for(int i = 0; i < m; i++) ret += 1ll * s[i] * dp[i] % mod;",
			"        return ret % mod;",
			"    }",
			"};",
			"// ex) a_i = a_{i-1} + 2*a_{i-2} / a_0 = 1, a_1 = 3",
			"//     res = ki.get_nth({ 1, 2 }, { 1, 3 }, n);",
			""
		]
	},
	"KMP": {
		"scope": "cpp",
		"prefix": "pskmp",
		"body": [
			"struct KMP",
			"{",
			"    vector<int> fail;",
			"",
			"    void init_fail(const string& w)",
			"    {",
			"        int wn = w.size();",
			"        fail.clear();",
			"        fail.resize(wn, 0);",
			"",
			"        int j = 0;",
			"        for(int i = 1; i < wn; ++i) {",
			"            while(j > 0 && w[i] != w[j]) {",
			"                j = fail[j - 1];",
			"            }",
			"            if(w[i] == w[j]) {",
			"                fail[i] = j + 1;",
			"                j++;",
			"            }",
			"        }",
			"    }",
			"",
			"    void get(const string& s, const string& w, vector<int>& res)",
			"    {",
			"        init_fail(w);",
			"        res.clear();",
			"",
			"        int sn = s.size();",
			"        int wn = w.size();",
			"",
			"        int j = 0;",
			"        for(int i = 0; i < sn; ++i) {",
			"            while(j > 0 && s[i] != w[j]) {",
			"                j = fail[j - 1];",
			"            }",
			"            if(s[i] == w[j]) {",
			"                j++;",
			"            }",
			"            if(j == wn) {",
			"                res.push_back(i - wn + 1);",
			"                j = fail[j - 1];",
			"            }",
			"        }",
			"    }",
			"};",
			""
		]
	},
	"Large Prime Factorization": {
		"scope": "cpp",
		"prefix": "pslargeprimefac",
		"body": [
			"vector<pair<ll, int>> largePrimeFac(ll v)",
			"{",
			"    vector<pair<ll, int>> res;",
			"    ll sqv = sqrtl(v);",
			"",
			"    for(ll f = 2; f <= sqv && v > 1; ++f) {",
			"        if(v % f != 0) continue;",
			"        res.emplace_back(f, 0);",
			"        while(v % f == 0) {",
			"            res.back().second++;",
			"            v /= f;",
			"        }",
			"    }",
			"    if(v > 1) res.emplace_back(v, 1);",
			"",
			"    return res;",
			"}",
			""
		]
	},
	"Lazy Segment Tree": {
		"scope": "cpp",
		"prefix": "pslazysegtree",
		"body": [
			"struct SegTree",
			"{",
			"    using Type = int;",
			"",
			"    Type merge(Type l, Type r)",
			"    {",
			"        return l + r;",
			"    }",
			"",
			"    const Type emptyNode = 0;",
			"",
			"    vector<Type> t;",
			"    vector<int> lazy;",
			"    int stLeaf, n;",
			"",
			"    SegTree(int n)",
			"    {",
			"        stLeaf = 1;",
			"        while(stLeaf < n) stLeaf *= 2;",
			"",
			"        t.resize(stLeaf * 2, emptyNode);",
			"        lazy.resize(stLeaf * 2, 0);",
			"    }",
			"",
			"    void initv(int idx, Type v)",
			"    {",
			"        t[stLeaf + idx] = v;",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for(int i = stLeaf - 1; i > 0; --i) {",
			"            t[i] = merge(t[i * 2], t[i * 2 + 1]);",
			"        }",
			"    }",
			"",
			"    void push(int l, int r, int node)",
			"    {",
			"        if(lazy[node] == 0) return;",
			"",
			"        if(node < stLeaf) {",
			"            lazy[node * 2] += lazy[node];",
			"            lazy[node * 2 + 1] += lazy[node];",
			"        }",
			"        t[node] += (r - l + 1) * lazy[node];",
			"        lazy[node] = 0;",
			"    }",
			"",
			"    Type queryImpl(int cl, int cr, int l, int r, int node)",
			"    {",
			"        push(cl, cr, node);",
			"        if(cr < l || r < cl) return emptyNode;",
			"        if(l <= cl && cr <= r) return t[node];",
			"        int m = (cl + cr) / 2;",
			"        return merge(queryImpl(cl, m, l, r, node * 2), queryImpl(m + 1, cr, l, r, node * 2 + 1));",
			"    }",
			"",
			"    void udtImpl(int cl, int cr, int l, int r, int node, Type v)",
			"    {",
			"        push(cl, cr, node);",
			"        if(cr < l || r < cl) return;",
			"        if(l <= cl && cr <= r) {",
			"            lazy[node] += v;",
			"            push(cl, cr, node);",
			"            return;",
			"        }",
			"        int m = (cl + cr) / 2;",
			"        udtImpl(cl, m, l, r, node * 2, v);",
			"        udtImpl(m + 1, cr, l, r, node * 2 + 1, v);",
			"        t[node] = merge(t[node * 2], t[node * 2 + 1]);",
			"    }",
			"",
			"    Type query(int l, int r)",
			"    {",
			"        return queryImpl(0, stLeaf - 1, l, r, 1);",
			"    }",
			"",
			"    void update(int l, int r, Type v)",
			"    {",
			"        udtImpl(0, stLeaf - 1, l, r, 1, v);",
			"    }",
			"};",
			""
		]
	},
	"Li-Chao Tree": {
		"scope": "cpp",
		"prefix": "pslichao",
		"body": [
			"template <bool isMax = false>",
			"struct LiChao",
			"{",
			"    struct Line",
			"    {",
			"        ll a, b; // y = ax + b",
			"        ll getvalue(ll x)",
			"        {",
			"            return x * a + b;",
			"        }",
			"    };",
			"    Line empty;",
			"",
			"    struct Node",
			"    {",
			"        int l = -1, r = -1;",
			"        ll xl, xr;",
			"        Line line;",
			"    };",
			"",
			"    vector<Node> d;",
			"",
			"    void init(ll xmin, ll xmax)",
			"    {",
			"        empty.a = 0;",
			"        empty.b = isMax ? -INF : INF;",
			"        d.push_back({ -1, -1, xmin, xmax, empty });",
			"    }",
			"",
			"    void insert(Line line, int node)",
			"    {",
			"        ll xl = d[node].xl;",
			"        ll xr = d[node].xr;",
			"        Line low = d[node].line;",
			"        Line high = line;",
			"        if(low.getvalue(xl) > high.getvalue(xl)) swap(low, high);",
			"",
			"        if(low.getvalue(xr) <= high.getvalue(xr)) {",
			"            d[node].line = isMax ? high : low;",
			"            return;",
			"        }",
			"",
			"        ll xm = (xl + xr) / 2;",
			"        if(low.getvalue(xm) > high.getvalue(xm)) {",
			"            // 왼쪽에 교점",
			"            d[node].line = isMax ? low : high;",
			"            if(d[node].l == -1) {",
			"                d[node].l = d.size();",
			"                d.push_back({ -1, -1, xl, xm, empty });",
			"            }",
			"            insert(low, d[node].l);",
			"        } else {",
			"            // 오른쪽에 교점",
			"            d[node].line = isMax ? high : low;",
			"            if(d[node].r == -1) {",
			"                d[node].r = d.size();",
			"                d.push_back({ -1, -1, xm + 1, xr, empty });",
			"            }",
			"            insert(high, d[node].r);",
			"        }",
			"    }",
			"",
			"    ll get(ll x, int node)",
			"    {",
			"        if(node == -1) return empty.b;",
			"",
			"        ll xl = d[node].xl;",
			"        ll xr = d[node].xr;",
			"        ll xm = (xl + xr) / 2;",
			"        ll res = d[node].line.getvalue(x);",
			"",
			"        ll cv;",
			"        if(x <= xm) cv = get(x, d[node].l);",
			"        else cv = get(x, d[node].r);",
			"",
			"        if(isMax == false) res = min(res, cv);",
			"        else res = max(res, cv);",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Main": {
		"scope": "cpp",
		"prefix": "psmain",
		"body": [
			"#define _CRT_SECURE_NO_WARNINGS 1",
			"#define _CRT_DECLARE_NONSTDC_NAMES 0 // for using y1 as variable name",
			"",
			"#include <iostream>",
			"#include <cstdio>",
			"#include <utility>",
			"#include <algorithm>",
			"#include <numeric>",
			"#include <vector>",
			"using namespace std;",
			"",
			"using ll = long long int;",
			"constexpr int INF = 0x3f3f3f3f;",
			"constexpr ll LNF = 0x3f3f3f3f3f3f3f3f;",
			"constexpr ll MOD = 1'000'000'007;",
			"",
			"void solve()",
			"{",
			"    ${0}",
			"}",
			"",
			"int main()",
			"{",
			"#ifdef CUBE_PS",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"#endif",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(0);",
			"",
			"    int tNum = 1;",
			"    // cin >> tNum;",
			"    for(int tt = 1; tt <= tNum; tt++) {",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"}",
			""
		]
	},
	"Manacher": {
		"scope": "cpp",
		"prefix": "psmanacher",
		"body": [
			"struct Manacher",
			"{",
			"    // d1: ab c ba -> 2",
			"    // d2: ab b a -> 2",
			"    vector<int> d1, d2;",
			"    void build(const string& str)",
			"    {",
			"        int n = str.size();",
			"        d1.clear();",
			"        d2.clear();",
			"",
			"        d1.resize(n);",
			"        int l = 0, r = -1;",
			"        for(int i = 0; i < n; ++i) {",
			"            int k = 1;",
			"            if(i <= r) {",
			"                k = min(d1[l + r - i], r - i);",
			"            }",
			"            while(0 <= i - k && i + k < n && str[i - k] == str[i + k]) k++;",
			"            d1[i] = --k;",
			"            if(i + k > r) {",
			"                r = i + k;",
			"                l = i - k;",
			"            }",
			"        }",
			"",
			"        d2.resize(n);",
			"        l = 0; r = -1;",
			"        for(int i = 0; i < n; ++i) {",
			"            int k = 0;",
			"            if(i <= r) {",
			"                k = min(d2[l + r - i + 1], r - i);",
			"            }",
			"            while(0 <= i - k - 1 && i + k < n && str[i - k - 1] == str[i + k]) k++;",
			"            d2[i] = k--;",
			"            if(i + k > r) {",
			"                r = i + k - 1;",
			"                l = i - k;",
			"            }",
			"        }",
			"    }",
			"};",
			""
		]
	},
	"Matrix": {
		"scope": "cpp",
		"prefix": "psmatrix",
		"body": [
			"struct Matrix",
			"{",
			"    vector<vector<ll>> d;",
			"    int n;",
			"",
			"    Matrix(int _n) : n(_n)",
			"    {",
			"        d.resize(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            d[i].resize(n);",
			"            for(int j = 0; j < n; ++j) {",
			"                if(i == j) d[i][j] = 1;",
			"                else d[i][j] = 0;",
			"            }",
			"        }",
			"    }",
			"    vector<ll>& operator[](int row) { return d[row]; }",
			"",
			"    void mulself()",
			"    {",
			"        Matrix tmp(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            for(int j = 0; j < n; ++j) {",
			"                tmp.d[i][j] = 0;",
			"                for(int k = 0; k < n; ++k) {",
			"                    tmp.d[i][j] += (d[i][k] * d[k][j]) % MOD;",
			"                    tmp.d[i][j] %= MOD;",
			"                }",
			"            }",
			"        }",
			"        d = move(tmp.d);",
			"    }",
			"",
			"    void mul(const Matrix& b)",
			"    {",
			"        Matrix tmp(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            for(int j = 0; j < n; ++j) {",
			"                tmp.d[i][j] = 0;",
			"                for(int k = 0; k < n; ++k) {",
			"                    tmp.d[i][j] += (d[i][k] * b.d[k][j]) % MOD;",
			"                    tmp.d[i][j] %= MOD;",
			"                }",
			"            }",
			"        }",
			"        d = move(tmp.d);",
			"    }",
			"",
			"    void pow(ll p)",
			"    {",
			"        Matrix res(n);",
			"        while(p > 0) {",
			"            if(p & 1) res.mul(*this);",
			"            mulself();",
			"            p >>= 1;",
			"        }",
			"        d = move(res.d);",
			"    }",
			"};",
			""
		]
	},
	"Min-Cost Max-Flow": {
		"scope": "cpp",
		"prefix": "psmcmf",
		"body": [
			"struct MCMF",
			"{",
			"    using Type = ll;",
			"    constexpr Type TINF = LNF;",
			"",
			"    struct Edge",
			"    {",
			"        int dst;",
			"        Type c;",
			"        Type f;",
			"        Type cost;",
			"        int revIdx;",
			"    };",
			"",
			"    vector<vector<Edge>> g;",
			"    vector<int> pre;",
			"    vector<Edge*> path;",
			"    vector<char> inQ;",
			"    vector<Type> dis;",
			"    int n;",
			"",
			"    MCMF(int _n)",
			"    {",
			"        n = _n;",
			"        g.resize(n);",
			"        pre.resize(n);",
			"        path.resize(n);",
			"        inQ.resize(n);",
			"        dis.resize(n);",
			"    }",
			"",
			"    void addEdge(int s, int e, Type c, Type cost)",
			"    {",
			"        Edge e1 = { e, c, 0, cost, -1 };",
			"        Edge e2 = { s, 0, 0, -cost, -1 };",
			"        e1.revIdx = g[e].size();",
			"        e2.revIdx = g[s].size();",
			"        g[s].push_back(e1);",
			"        g[e].push_back(e2);",
			"    }",
			"",
			"    void addFlow(Edge& e, Type f)",
			"    {",
			"        e.f += f;",
			"        g[e.dst][e.revIdx].f -= f;",
			"    }",
			"",
			"    pair<Type, Type> flow(int st, int ed)",
			"    {",
			"        for(int i = 0; i < n; ++i) {",
			"            pre[i] = -1;",
			"            inQ[i] = false;",
			"            dis[i] = INF;",
			"        }",
			"        queue<int> q;",
			"        q.push(st);",
			"        inQ[st] = true;",
			"        dis[st] = 0;",
			"        while(q.empty() == false) {",
			"            int cur = q.front();",
			"            q.pop();",
			"            inQ[cur] = false;",
			"            for(auto& nx : g[cur]) {",
			"                int nxt = nx.dst;",
			"                Type c = nx.c;",
			"                Type f = nx.f;",
			"                Type cost = nx.cost;",
			"                if(c > f && dis[nxt] > dis[cur] + cost) {",
			"                    dis[nxt] = dis[cur] + cost;",
			"                    pre[nxt] = cur;",
			"                    path[nxt] = &nx;",
			"                    if(inQ[nxt] == false) {",
			"                        q.push(nxt);",
			"                        inQ[nxt] = true;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        if(pre[ed] == -1) return { 0, 0 };",
			"        Type flow = TINF;",
			"        int idx = ed;",
			"        while(idx != st) {",
			"            flow = min(flow, path[idx]->c - path[idx]->f);",
			"            idx = pre[idx];",
			"        }",
			"        idx = ed;",
			"        Type cost = 0;",
			"        while(idx != st) {",
			"            addFlow(*path[idx], flow);",
			"            cost += path[idx]->cost * flow;",
			"            idx = pre[idx];",
			"        }",
			"        return { flow, cost };",
			"    }",
			"",
			"    pair<Type, Type> mcmf(int st, int ed)",
			"    {",
			"        pair<Type, Type> res = { 0, 0 };",
			"        while(1) {",
			"            pair<Type, Type> f = flow(st, ed);",
			"            if(f.first == 0) break;",
			"            res.first += f.first;",
			"            res.second += f.second;",
			"        }",
			"",
			"        return res;",
			"    }",
			"};",
			""
		]
	},
	"Modular Integer": {
		"scope": "cpp",
		"prefix": "psmodint",
		"body": [
			"template <int mod>",
			"struct ModInt",
			"{",
			"    ll v;",
			"    ModInt(ll _v = 0) : v((_v % mod + mod) % mod) {}",
			"    ModInt& operator+=(const ModInt& rhs) {",
			"        v += rhs.v;",
			"        if(v >= mod) v -= mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator-=(const ModInt& rhs) {",
			"        v -= rhs.v;",
			"        if(v < 0) v += mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator*=(const ModInt& rhs) {",
			"        v *= rhs.v;",
			"        v %= mod;",
			"        return *this;",
			"    }",
			"    ModInt& operator/=(const ModInt& rhs) {",
			"        ll n = mod - 2;",
			"        ModInt rev = 1, b = rhs;",
			"        while(n > 0) {",
			"            if(n & 1) rev *= b;",
			"            b *= b;",
			"            n >>= 1;",
			"        }",
			"        return *this *= rev;",
			"    }",
			"    ModInt operator+(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs += rhs;",
			"    }",
			"    ModInt operator-() const { return ModInt() -= *this; }",
			"    ModInt operator-(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs -= rhs;",
			"    }",
			"    ModInt operator*(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs *= rhs;",
			"    }",
			"    ModInt operator/(const ModInt& rhs) const {",
			"        ModInt lhs(*this);",
			"        return lhs /= rhs;",
			"    }",
			"    friend std::ostream& operator<<(std::ostream& os, const ModInt& n) { return os << n.v; }",
			"    friend std::istream& operator>>(std::istream& is, ModInt& n) {",
			"        ll x;",
			"        is >> x;",
			"        n = ModInt(x);",
			"        return is;",
			"    }",
			"    bool operator==(const ModInt& rhs) const { return v == rhs.v; }",
			"    bool operator!=(const ModInt& rhs) const { return v != rhs.v; }",
			"    ModInt pow(ll k) const {",
			"        ModInt res = 1, p = v;",
			"        while(k > 0) {",
			"            if(k & 1) res *= p;",
			"            p *= p;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"using mint = ModInt<MOD>;",
			""
		]
	},
	"Number-Theoretic Transform": {
		"scope": "cpp",
		"prefix": "psntt",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/NumberTheoreticTransform.h",
			"template <int MOD, int ROOT>",
			"struct NTT",
			"{",
			"    ll modpow(ll a, ll b)",
			"    {",
			"        ll res = 1;",
			"        ll p = a;",
			"        while(b > 0) {",
			"            if(b & 1) {",
			"                res = (res * p) % MOD;",
			"            }",
			"            p = (p * p) % MOD;",
			"            b >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void ntt(vector<ll>& a)",
			"    {",
			"        int n = a.size(), L = 0;",
			"        while(n > 1) {",
			"            n >>= 1;",
			"            L++;",
			"        }",
			"        n = a.size();",
			"        static vector<ll> rt(2, 1);",
			"        for(static int k = 2, s = 2; k < n; k *= 2, s++) {",
			"            rt.resize(n);",
			"            ll z[] = { 1, modpow(ROOT, MOD >> s) };",
			"            for(int i = k; i < 2 * k; ++i) {",
			"                rt[i] = rt[i / 2] * z[i & 1] % MOD;",
			"            }",
			"        }",
			"        vector<int> rev(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"        }",
			"        for(int i = 0; i < n; ++i) {",
			"            if(i < rev[i]) swap(a[i], a[rev[i]]);",
			"        }",
			"        for(int k = 1; k < n; k *= 2) {",
			"            for(int i = 0; i < n; i += 2 * k) {",
			"                for(int j = 0; j < k; ++j) {",
			"                    ll z = rt[j + k] * a[i + j + k] % MOD, &ai = a[i + j];",
			"                    a[i + j + k] = ai - z + (z > ai ? MOD : 0);",
			"                    ai += (ai + z >= MOD ? z - MOD : z);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<ll> conv(const vector<ll>& a, const vector<ll>& b)",
			"    {",
			"        if(a.empty() || b.empty()) return {};",
			"        int s = a.size() + b.size() - 1;",
			"        int B = 0, n = 1;",
			"        while(n <= s) {",
			"            n <<= 1;",
			"            B++;",
			"        }",
			"        ll inv = modpow(n, MOD - 2);",
			"        vector<ll> L(a), R(b), out(n);",
			"        L.resize(n), R.resize(n);",
			"        ntt(L), ntt(R);",
			"        for(int i = 0; i < n; ++i) {",
			"            out[-i & (n - 1)] = (ll)L[i] * R[i] % MOD * inv % MOD;",
			"        }",
			"        ntt(out);",
			"        return { out.begin(), out.begin() + s };",
			"    }",
			"};",
			"",
			"// NTT<998244353, 62> ntt;",
			"// NTT<998244353, 3> ntt;",
			"// NTT<167772161, 3> ntt;",
			"// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
			"// and 483 << 21 (same root). The last two are > 10^9.",
			""
		]
	},
	"Persistence Segment Tree": {
		"scope": "cpp",
		"prefix": "pspst",
		"body": [
			"struct PST",
			"{",
			"    using Type = ll;",
			"",
			"    Type merge(Type l, Type r)",
			"    {",
			"        return l + r;",
			"    }",
			"",
			"    const Type emptyNode = 0;",
			"",
			"    struct Node",
			"    {",
			"        int l = -1, r = -1;",
			"        Type v = 0;",
			"    };",
			"",
			"    vector<Node> t;",
			"    int stLeaf;",
			"    vector<int> root;",
			"",
			"    void init(int n)",
			"    {",
			"        t.clear();",
			"        root.clear();",
			"        root.push_back(1);",
			"",
			"        stLeaf = 1;",
			"        while(stLeaf < n) stLeaf *= 2;",
			"        t.resize(stLeaf * 2);",
			"    }",
			"",
			"    void initv(int idx, Type v)",
			"    {",
			"        t[stLeaf + idx].v = v;",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for(int i = stLeaf - 1; i > 0; --i) {",
			"            t[i].v = merge(t[i * 2].v, t[i * 2 + 1].v);",
			"            t[i].l = i * 2;",
			"            t[i].r = i * 2 + 1;",
			"        }",
			"    }",
			"",
			"    Type queryImpl(int cl, int cr, int l, int r, int node)",
			"    {",
			"        if(l <= cl && cr <= r) return t[node].v;",
			"        else if(cr < l || r < cl) return emptyNode;",
			"        int m = (cl + cr) / 2;",
			"        return merge(queryImpl(cl, m, l, r, t[node].l), queryImpl(m + 1, cr, l, r, t[node].r));",
			"    }",
			"",
			"    Type query(int l, int r, int version)",
			"    {",
			"        return queryImpl(0, stLeaf - 1, l, r, root[version]);",
			"    }",
			"",
			"    void update(int idx, Type v)",
			"    {",
			"        int cl = 0, cr = stLeaf - 1;",
			"        int node = root.back();",
			"",
			"        int newnode = t.size();",
			"        root.push_back(newnode);",
			"        t.push_back(t[node]);",
			"",
			"        while(cl != cr) {",
			"            int m = (cl + cr) / 2;",
			"            if(idx <= m) {",
			"                cr = m;",
			"                t[newnode].l = newnode + 1;",
			"                newnode++;",
			"",
			"                node = t[node].l;",
			"                t.push_back(t[node]);",
			"            } else {",
			"                cl = m + 1;",
			"                t[newnode].r = newnode + 1;",
			"                newnode++;",
			"",
			"                node = t[node].r;",
			"                t.push_back(t[node]);",
			"            }",
			"        }",
			"        t[newnode].v = v;",
			"        newnode--;",
			"        while(newnode >= root.back()) {",
			"            t[newnode].v = merge(t[t[newnode].l].v, t[t[newnode].r].v);",
			"            newnode--;",
			"        }",
			"    }",
			"",
			"    void remove(int numrt)",
			"    {",
			"        int rmrt = root[root.size() - numrt];",
			"        t.erase(t.begin() + rmrt, t.end());",
			"        root.erase(root.end() - numrt, root.end());",
			"    }",
			"};",
			""
		]
	},
	"Random": {
		"scope": "cpp",
		"prefix": "psrandom",
		"body": [
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"uniform_int_distribution<int> distribution(0, INT_MAX);",
			"int getRandom() { return distribution(rng); }",
			""
		]
	},
	"Rotating Calipers_old": {
		"scope": "cpp",
		"prefix": "psrotatingcalipers",
		"body": [
			"ll rotatingCalipers(vector<Point>& cvh)",
			"{",
			"    ll res = 0;",
			"    int cvhn = cvh.size();",
			"",
			"    int aidx = 0, bidx = 0;",
			"    for(int i = 1; i < cvhn; ++i) {",
			"        ll l = lensq(cvh[0], cvh[i]);",
			"        if(res < l) {",
			"            res = l;",
			"            bidx = i;",
			"        }",
			"    }",
			"    for(int i = 0; i < cvhn; ++i) {",
			"        ll l = lensq(cvh[aidx], cvh[bidx]);",
			"        if(res < l) {",
			"            res = l;",
			"        }",
			"        Point av = cvh[(aidx + 1) % cvhn] - cvh[aidx];",
			"        Point bv = cvh[(bidx + 1) % cvhn] - cvh[bidx];",
			"        bv.x = -bv.x;",
			"        bv.y = -bv.y;",
			"        if(ccw(av, bv) > 0) {",
			"            aidx++;",
			"            aidx %= cvhn;",
			"        } else {",
			"            bidx++;",
			"            bidx %= cvhn;",
			"        }",
			"    }",
			"",
			"    return res;",
			"}"
		]
	},
	"SCC": {
		"scope": "cpp",
		"prefix": "psscc",
		"body": [
			"vector<int> d(n, 0), st(n), finish(n, false), sccIdx(n);",
			"vector<vector<int>> sccs;",
			"int dNum = 0;",
			"",
			"auto scc_dfs = [&](auto&& self, int cur) -> int {",
			"    d[cur] = ++dNum;",
			"    st.push_back(cur);",
			"",
			"    int ret = d[cur];",
			"    for(int nxt : g[cur]) {",
			"        if(d[nxt] == 0) ret = min(ret, self(self, nxt));",
			"        else if(finish[nxt] == false) ret = min(ret, d[nxt]);",
			"    }",
			"",
			"    if(ret == d[cur]) {",
			"        sccs.push_back({});",
			"        auto& scc = sccs.back();",
			"        while(1) {",
			"            int top = st.back();",
			"            st.pop_back();",
			"",
			"            scc.push_back(top);",
			"            sccIdx[top] = sccs.size();",
			"            finish[top] = true;",
			"",
			"            if(top == cur) break;",
			"        }",
			"    }",
			"    return ret;",
			"};",
			"for(int i = 0; i < n; ++i) {",
			"    if(d[i] == 0) scc_dfs(scc_dfs, i);",
			"}",
			""
		]
	},
	"Segment Tree": {
		"scope": "cpp",
		"prefix": "pssegtree",
		"body": [
			"struct SegTree",
			"{",
			"    using Type = ll;",
			"",
			"    Type merge(Type l, Type r)",
			"    {",
			"        return l + r;",
			"    }",
			"",
			"    const Type emptyNode = 0;",
			"",
			"    int n;",
			"    vector<Type> t;",
			"",
			"    SegTree(int _n)",
			"    {",
			"        n = _n;",
			"        t.resize(n * 2, emptyNode);",
			"    }",
			"",
			"    void initv(int idx, Type v)",
			"    {",
			"        t[n + idx] = v;",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for(int i = n - 1; i > 0; --i) {",
			"            t[i] = merge(t[i << 1], t[i << 1 | 1]);",
			"        }",
			"    }",
			"",
			"    void update(int idx, Type v)",
			"    {",
			"        idx += n;",
			"        t[idx] = v;",
			"        idx >>= 1;",
			"        while(idx > 0) {",
			"            t[idx] = merge(t[idx << 1], t[idx << 1 | 1]);",
			"            idx >>= 1;",
			"        }",
			"    }",
			"",
			"    Type query(int l, int r)",
			"    {",
			"        l += n;",
			"        r += n + 1;",
			"        Type resl = emptyNode;",
			"        Type resr = emptyNode;",
			"        while(l < r) {",
			"            if(l & 1) resl = merge(resl, t[l++]);",
			"            if(r & 1) resr = merge(t[--r], resr);",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"        return merge(resl, resr);",
			"    }",
			"};",
			""
		]
	},
	"Sieve(MinFactor,Mobius,Prime,Phi) + Prime Fac": {
		"scope": "cpp",
		"prefix": "pssieve",
		"body": [
			"vector<int> minFactor, mobius, primes, phi;",
			"void initSieve(int n)",
			"{",
			"    minFactor.resize(n + 1, 0);",
			"    // mobius.resize(n + 1, 0);",
			"    // mobius[1] = 1;",
			"    for(int i = 2; i <= n; i++) {",
			"        if(minFactor[i] == 0) {",
			"            minFactor[i] = i;",
			"            primes.push_back(i);",
			"        }",
			"        for(int p : primes) {",
			"            if(i * p > n) break;",
			"            minFactor[i * p] = p;",
			"            // mobius[i * p] = (i % p != 0) * (-mobius[i]);",
			"            if(i % p == 0) break;",
			"        }",
			"    }",
			"",
			"    // euler phi",
			"    /*",
			"    phi.resize(n + 1, 0);",
			"    iota(phi.begin(), phi.end(), 0);",
			"    for(int i = 2; i <= n; ++i) {",
			"        if(minFactor[i] != i) continue;",
			"        for(int j = 1; j * i <= n; ++j) {",
			"            phi[i * j] = (i - 1) * (phi[i * j] / i);",
			"        }",
			"    }",
			"    */",
			"}",
			"// phi[i] = (p^a - p^(a-1))...",
			"",
			"vector<pair<int, int>> primeFac(int v)",
			"{",
			"    vector<pair<int, int>> res;",
			"",
			"    while(v > 1) {",
			"        int f = minFactor[v];",
			"        if(res.size() == 0 || res.back().first != f) res.emplace_back(f, 0);",
			"        res.back().second++;",
			"        v /= f;",
			"    }",
			"",
			"    return res;",
			"}",
			""
		]
	},
	"Suffix Array": {
		"scope": "cpp",
		"prefix": "pssuffixarray",
		"body": [
			"// https://github.com/kth-competitive-programming/kactl/blob/main/content/strings/SuffixArray.h",
			"struct SuffixArray",
			"{",
			"    vector<int> sa, lcp;",
			"    vector<int> ori, lg2;",
			"    vector<vector<int>> st;",
			"",
			"    SuffixArray(string& s, int lim = 256)",
			"    {",
			"        // or basic_string<int>",
			"        int n = s.size() + 1, k = 0, a, b;",
			"        vector<int> x(s.begin(), s.end()), y(n), ws(max(n, lim)), rank(n);",
			"        x.push_back(0);",
			"        sa = lcp = y, iota(sa.begin(), sa.end(), 0);",
			"        for(int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
			"            p = j, iota(y.begin(), y.end(), n - j);",
			"            for(int i = 0; i < n; ++i) if(sa[i] >= j) y[p++] = sa[i] - j;",
			"            fill(ws.begin(), ws.end(), 0);",
			"            for(int i = 0; i < n; ++i) ws[x[i]]++;",
			"            for(int i = 1; i < lim; ++i) ws[i] += ws[i - 1];",
			"            for(int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
			"            swap(x, y), p = 1, x[sa[0]] = 0;",
			"            for(int i = 1; i < n; ++i) {",
			"                a = sa[i - 1], b = sa[i];",
			"                x[b] = (y[a] == y[b] && a + j < n && b + j < n && y[a + j] == y[b + j]) ? p - 1 : p++;",
			"            }",
			"        }",
			"        for(int i = 1; i < n; ++i) rank[sa[i]] = i;",
			"        for(int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
			"            for(k && k--, j = sa[rank[i] - 1];",
			"                i + k < n - 1 && j + k < n - 1 && s[i + k] == s[j + k]; k++);",
			"",
			"        // lcp RMQ build",
			"        lg2.resize(n + 1);",
			"        lg2[0] = lg2[1] = 0;",
			"        for(int i = 2; i <= n; ++i) {",
			"            lg2[i] = lg2[i / 2] + 1;",
			"        }",
			"",
			"        ori.resize(n);",
			"        int dep = lg2[n];",
			"        st.resize(n);",
			"        for(int i = 0; i < n; ++i) {",
			"            ori[sa[i]] = i;",
			"            st[i].resize(dep + 1);",
			"            st[i][0] = lcp[i];",
			"        }",
			"        for(int j = 1; j <= dep; ++j) {",
			"            for(int i = 0; i + (1 << (j - 1)) < n; ++i) {",
			"                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"            }",
			"        }",
			"    }",
			"",
			"    int get_lcp(int l, int r)",
			"    {",
			"        if(l == r) return sa.size() - l - 1;",
			"        l = ori[l], r = ori[r];",
			"        if(l > r) swap(l, r);",
			"        int j = lg2[r - l];",
			"        return min(st[l + 1][j], st[r - (1 << j) + 1][j]);",
			"    }",
			"};",
			"// sa[0] = str.size(), sa.size() = str.size() + 1",
			"// lcp[i] = lcp(sa[i - 1], sa[i]), lcp[0] = 0",
			""
		]
	},
	"TLE Trick": {
		"scope": "cpp",
		"prefix": "pstle",
		"body": [
			"#ifndef CUBE_PS",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#endif",
			""
		]
	},
	"Ternary Search": {
		"scope": "cpp",
		"prefix": "pstsearch",
		"body": [
			"auto tsearch = [](ll minx, ll maxx, const function<ll(ll)>& tfunc) {",
			"    ll l = minx, r = maxx;",
			"    while(l + 2 < r) {",
			"        ll p = (l * 2 + r) / 3;",
			"        ll q = (l + r * 2) / 3;",
			"",
			"        ll pv = tfunc(p);",
			"        ll qv = tfunc(q);",
			"",
			"        // min",
			"        if(pv <= qv) r = q;",
			"        else l = p;",
			"        // max",
			"        if(pv <= qv) l = p;",
			"        else r = q;",
			"    }",
			"",
			"    ll res = tfunc(l);",
			"    for(ll i = l + 1; i <= r; ++i) {",
			"        // min",
			"        res = min(res, tfunc(i));",
			"        // max",
			"        res = max(res, tfunc(i));",
			"    }",
			"    return res;",
			"};",
			""
		]
	},
	"Z-Function": {
		"scope": "cpp",
		"prefix": "pszfunction",
		"body": [
			"struct ZFunc",
			"{",
			"    vector<int> z;",
			"    void build(const string& s)",
			"    {",
			"        int n = (int)s.size();",
			"        z.clear();",
			"        z.resize(s.size());",
			"        for(int i = 1, l = 0, r = 0; i < n; ++i) {",
			"            if(i <= r) z[i] = min(r - i + 1, z[i - l]);",
			"            while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
			"            if(i + z[i] - 1 > r) {",
			"                l = i;",
			"                r = i + z[i] - 1;",
			"            }",
			"        }",
			"    }",
			"};",
			""
		]
	},
	"Temp": {
		"scope": "cpp",
		"prefix": "pstemp",
		"body": []
	},
}
