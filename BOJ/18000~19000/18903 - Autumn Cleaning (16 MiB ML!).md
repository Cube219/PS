---
author: Cube219
created: 2022-12-02T12:31:50+09:00
updated: 2022-12-02T12:31:50+09:00
---

[18903번: Autumn Cleaning (16 MiB ML!)](https://www.acmicpc.net/problem/18903)

# 풀이

모든 물건들을 mod R 한 것을 인덱스로 해서 `cnt` 배열에 넣자. 그러면 `dp[r][x]` = `x`개를 고르고 (합 mod R)이 `r`인 경우의 수로 식을 세우면, `cnt` 배열을 순회하면서 `[0, k]`개 선택했을 때 경우의 수로 dp값을 갱신하면 된다. 이러면 $O(K^2 R^2)$으로, 상수컷팅을 빡세게 하면 가능하다.

여기서 dp값을 갱신할 때 `x`개를 고르는 경우에서, `cnt` 배열을 `k`개를 고르면 이전 dp에서는 `x-k`개를 고르는 경우에서 가져와야 한다. 이것을 보면 FFT를 쓰면 더 빠르게 가능할 것 같다.

![|500](attachments/Pasted%20image%2020221202123255.png)

현재 `cnt[2]`인 경우라 생각하자. 여기에서 `[0, k]`개를 선택했을 때 (합 mod R)이 `r1`이다. 그러면 똑같은 간격으로 `r2`를 구성하고 convolution을 돌린다면, 결과값에 있는 모든 mod R은 동일해진다.

이 성질을 이용해, `r1`은 고정시키고 `r2`만 시작을 `[0, R)`로 하면 모든 경우를 구할 수 있다. `r1`은 `cnt`에 대응시키고, `r2`는 이전 dp에 대응시키고, `(r1+r2)`는 현재 dp에 대응시켜서 값을 구하면 된다. 이러면 $O(R^2 KlogK)$에 구할 수 있다.

메모리 제한이 빡세므로 가능하면 배열들은 `int`로 해주고, FFT도 정확도 높은 FFT를 써야한다.
