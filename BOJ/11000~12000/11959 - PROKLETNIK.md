---
author: Cube219
created: 2022-11-30T20:52:19+09:00
updated: 2022-11-30T20:52:19+09:00
---

[11959번: PROKLETNIK](https://www.acmicpc.net/problem/11959)

# 풀이

magical 구역을 왼쪽이 최소, 오른쪽이 최대로 바꾸자. 나중에 배열을 뒤집어서 똑같이 하면 된다.

`a[i]`를 `i`에서 시작해서 최대 magical size라 하고 이 배열을 0부터 시작해 업데이트하자. 쿼리를 `r`을 기준으로 정렬하면, `max[a[l], a[r]]`로 처리할 수 있다.

`d[r]`가 구역의 맨 오른쪽일 때, `i < r`, `d[i] > d[r]`인 가장 오른쪽 `i`를 `l`이라 하면 `[l + 1, r]`범위를 업데이트 할 수 있다. 더 왼쪽은 `d[i]`에 의해 `d[r]`이 최대가 안 되기 때문이다. 또한 `d[i] > d[r]`인 모든 `i`들은 앞으로 갱신되지 않는다. `d[r]`이 포함되면서 `d[i]`가 최소가 되지 않기 때문이다.

전자를 레이지 세그로 처리하자. 세그 노드로 최대 길이(`v`), 최대 오른쪽(`r`), 제외되지 않은 맨 왼쪽 `l`(`mnL`)을 담고, 갱신할 때 `r`값을 max seg로 업데이트한다. 이때 lazy는 `r`이 -1인지 아닌지로 판단한다.

-1이면 이미 밑으로 push됬기 때문에 자식의 `v`값을 `max`로 가져오면 되고, 아니면 `mnL`과 `r`로 `v`를 구하고 push한다. 제외시키는 것은 `mnL`값을 수정해서 구현한다.

업데이트 범위는 좌표압축+세그로 구현한다 (스택으로도 할 수 있는듯?)

후자에서 제외시킬 값들은 그냥 이전에 살아있는 값들을 set으로 관리해 set에서 꺼내서 제외시킨다.
