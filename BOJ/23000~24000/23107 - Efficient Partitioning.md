---
author: Cube219
created: 2023-12-03T22:38:55+09:00
updated: 2023-12-03T22:38:55+09:00
---

[23107번: Efficient Partitioning](https://www.acmicpc.net/problem/23107)

# 풀이

* 1. 세그트리+좌표압축
    * DP식을 세워보면, dp[i] = max{j=0~i-1}( min(dp[j], asum[i]-asum[j]+b[j+1]+c[i]) )가 된다. min이 문제인데, 아래 부등식과 같이 세우면 좌/우변에 각각 j/i로 몰아줄 수 있다. 그러면 이제 부등식을 만족하는 경우에는 dp[j]를 적용하고, 아니면 우변을 적용하면 된다.
    * ![](attachments/FYgU3DiakAAJMry%201.jpg)
    * 이것을 세그트리+좌표압축으로 해결해보자. asum[i]+c[i]값들을 기준으로 좌표압축을 한다. 여기에 편의를 위해 -INF도 추가하자. 그리고 세그트리를 $[v[i], v[i+1])$범위에서 최댓값으로 정의하고, 세그1에는 dp[j]를, 세그2에는 -asum[j]+b[j+1]을 저장하자.
    * asum[i]+c[i]보다 작은 범위는 dp[j]를 적용해야 하므로 세그1, 크거나 같은 범위는 세그2를 이용해 최댓값을 구한다. 그리고 dp[j]+asum[j]-b[j+1]에 해당하는 범위를 찾아서 세그1과 2를 업데이트 해준다.
* 2. parametric search
    * k보다 크거나 같도록 그룹을 나눌 수 있는지 확인해보자. 먼저 b[0]에서 시작해 a를 차례대로 더해준다. 만약 현재값 + c[i] >= k라면 이제 그룹을 나눌 수 있다. 나누는 경우, 현재값은 b[i+1]이 되고, 아니면 현재값은 변화가 없다.
    * 그러므로 현재값 < b[i+1]일때만 나누는 것이 최선의 이득이다. 이것을 하다가 마지막에 k보다 크거나 같으면 true, 아니면 false이다.
